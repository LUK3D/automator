// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.1
//   protoc               v6.33.0
// source: emulator_controller.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type ClientWritableStream,
  type handleClientStreamingCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty } from "./google/protobuf/empty";

export const protobufPackage = "android.emulation.control";

/**
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * Note that if you add/remove methods in this file you must update
 * the metrics sql as well ./android/scripts/gen-grpc-sql.py
 *
 * Please group deleted methods in a block including the date (MM/DD/YY)
 * it was removed. This enables us to easily keep metrics around after removal
 *
 * List of deleted methods
 * rpc iWasDeleted (03/12/12)
 * ...
 */

/** in line with android/emulation/resizable_display_config.h */
export enum DisplayModeValue {
  PHONE = 0,
  FOLDABLE = 1,
  TABLET = 2,
  DESKTOP = 3,
  UNRECOGNIZED = -1,
}

export function displayModeValueFromJSON(object: any): DisplayModeValue {
  switch (object) {
    case 0:
    case "PHONE":
      return DisplayModeValue.PHONE;
    case 1:
    case "FOLDABLE":
      return DisplayModeValue.FOLDABLE;
    case 2:
    case "TABLET":
      return DisplayModeValue.TABLET;
    case 3:
    case "DESKTOP":
      return DisplayModeValue.DESKTOP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DisplayModeValue.UNRECOGNIZED;
  }
}

export function displayModeValueToJSON(object: DisplayModeValue): string {
  switch (object) {
    case DisplayModeValue.PHONE:
      return "PHONE";
    case DisplayModeValue.FOLDABLE:
      return "FOLDABLE";
    case DisplayModeValue.TABLET:
      return "TABLET";
    case DisplayModeValue.DESKTOP:
      return "DESKTOP";
    case DisplayModeValue.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A Run State that describes the state of the Virtual Machine. */
export interface VmRunState {
  state: VmRunState_RunState;
}

export enum VmRunState_RunState {
  /**
   * UNKNOWN - The emulator is in an unknown state. You cannot transition to this
   * state.
   */
  UNKNOWN = 0,
  /**
   * RUNNING - Guest is actively running. You can transition to this state from the
   * paused state.
   */
  RUNNING = 1,
  /**
   * RESTORE_VM - Guest is paused to load a snapshot. You cannot transition to this
   * state.
   */
  RESTORE_VM = 2,
  /**
   * PAUSED - Guest has been paused. Transitioning to this state will pause the
   * emulator the guest will not be consuming any cpu cycles.
   */
  PAUSED = 3,
  /**
   * SAVE_VM - Guest is paused to take or export a snapshot. You cannot
   * transition to this state.
   */
  SAVE_VM = 4,
  /**
   * SHUTDOWN - System shutdown, note that it is similar to power off. It tries to
   * set the system status and notify guest. The system is likely going to
   * disappear soon and do proper cleanup of resources, possibly taking
   * a snapshot. This is the same behavior as closing the emulator by
   * clicking the X (close) in the user interface.
   */
  SHUTDOWN = 5,
  /**
   * TERMINATE - Immediately terminate the emulator. No resource cleanup will take
   * place. There is a good change to corrupt the system.
   */
  TERMINATE = 7,
  /**
   * RESET - Will cause the emulator to reset. This is not a state you can
   * observe.
   */
  RESET = 9,
  /**
   * INTERNAL_ERROR - Guest experienced some error state, you cannot transition to this
   * state.
   */
  INTERNAL_ERROR = 10,
  /** RESTART - Completely restart the emulator. */
  RESTART = 11,
  /** START - Resume a stopped emulator */
  START = 12,
  /** STOP - Stop (pause) a running emulator */
  STOP = 13,
  UNRECOGNIZED = -1,
}

export function vmRunState_RunStateFromJSON(object: any): VmRunState_RunState {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return VmRunState_RunState.UNKNOWN;
    case 1:
    case "RUNNING":
      return VmRunState_RunState.RUNNING;
    case 2:
    case "RESTORE_VM":
      return VmRunState_RunState.RESTORE_VM;
    case 3:
    case "PAUSED":
      return VmRunState_RunState.PAUSED;
    case 4:
    case "SAVE_VM":
      return VmRunState_RunState.SAVE_VM;
    case 5:
    case "SHUTDOWN":
      return VmRunState_RunState.SHUTDOWN;
    case 7:
    case "TERMINATE":
      return VmRunState_RunState.TERMINATE;
    case 9:
    case "RESET":
      return VmRunState_RunState.RESET;
    case 10:
    case "INTERNAL_ERROR":
      return VmRunState_RunState.INTERNAL_ERROR;
    case 11:
    case "RESTART":
      return VmRunState_RunState.RESTART;
    case 12:
    case "START":
      return VmRunState_RunState.START;
    case 13:
    case "STOP":
      return VmRunState_RunState.STOP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VmRunState_RunState.UNRECOGNIZED;
  }
}

export function vmRunState_RunStateToJSON(object: VmRunState_RunState): string {
  switch (object) {
    case VmRunState_RunState.UNKNOWN:
      return "UNKNOWN";
    case VmRunState_RunState.RUNNING:
      return "RUNNING";
    case VmRunState_RunState.RESTORE_VM:
      return "RESTORE_VM";
    case VmRunState_RunState.PAUSED:
      return "PAUSED";
    case VmRunState_RunState.SAVE_VM:
      return "SAVE_VM";
    case VmRunState_RunState.SHUTDOWN:
      return "SHUTDOWN";
    case VmRunState_RunState.TERMINATE:
      return "TERMINATE";
    case VmRunState_RunState.RESET:
      return "RESET";
    case VmRunState_RunState.INTERNAL_ERROR:
      return "INTERNAL_ERROR";
    case VmRunState_RunState.RESTART:
      return "RESTART";
    case VmRunState_RunState.START:
      return "START";
    case VmRunState_RunState.STOP:
      return "STOP";
    case VmRunState_RunState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ParameterValue {
  data: number[];
}

export interface PhysicalModelValue {
  target: PhysicalModelValue_PhysicalType;
  /** [Output Only] */
  status: PhysicalModelValue_State;
  /** Value interpretation depends on sensor. */
  value: ParameterValue | undefined;
}

export enum PhysicalModelValue_State {
  OK = 0,
  /** NO_SERVICE - qemud service is not available/initiated. */
  NO_SERVICE = -3,
  /** DISABLED - Sensor is disabled. */
  DISABLED = -2,
  /** UNKNOWN - Unknown sensor (should not happen) */
  UNKNOWN = -1,
}

export function physicalModelValue_StateFromJSON(object: any): PhysicalModelValue_State {
  switch (object) {
    case 0:
    case "OK":
      return PhysicalModelValue_State.OK;
    case -3:
    case "NO_SERVICE":
      return PhysicalModelValue_State.NO_SERVICE;
    case -2:
    case "DISABLED":
      return PhysicalModelValue_State.DISABLED;
    case -1:
    case "UNKNOWN":
      return PhysicalModelValue_State.UNKNOWN;
    default:
      return PhysicalModelValue_State.UNKNOWN;
  }
}

export function physicalModelValue_StateToJSON(object: PhysicalModelValue_State): string {
  switch (object) {
    case PhysicalModelValue_State.OK:
      return "OK";
    case PhysicalModelValue_State.NO_SERVICE:
      return "NO_SERVICE";
    case PhysicalModelValue_State.DISABLED:
      return "DISABLED";
    case PhysicalModelValue_State.UNKNOWN:
      return "UNKNOWN";
    default:
      return "UNKNOWN";
  }
}

/**
 * Details on the sensors documentation can be found here:
 * https://developer.android.com/reference/android/hardware/Sensor.html#TYPE_
 * The types must follow the order defined in
 * "external/qemu/android/hw-sensors.h"
 */
export enum PhysicalModelValue_PhysicalType {
  POSITION = 0,
  /**
   * ROTATION - All values are angles in degrees.
   * values = [x,y,z]
   */
  ROTATION = 1,
  MAGNETIC_FIELD = 2,
  /** TEMPERATURE - Temperature in °C */
  TEMPERATURE = 3,
  /** PROXIMITY - Proximity sensor distance measured in centimeters */
  PROXIMITY = 4,
  /** LIGHT - Ambient light level in SI lux units */
  LIGHT = 5,
  /** PRESSURE - Atmospheric pressure in hPa (millibar) */
  PRESSURE = 6,
  /** HUMIDITY - Relative ambient air humidity in percent */
  HUMIDITY = 7,
  VELOCITY = 8,
  AMBIENT_MOTION = 9,
  /** HINGE_ANGLE0 - Describing a hinge angle sensor in degrees. */
  HINGE_ANGLE0 = 10,
  HINGE_ANGLE1 = 11,
  HINGE_ANGLE2 = 12,
  ROLLABLE0 = 13,
  ROLLABLE1 = 14,
  ROLLABLE2 = 15,
  /**
   * POSTURE - Describing the device posture; the value should be an enum defined
   * in Posture::PostureValue.
   */
  POSTURE = 16,
  /** HEART_RATE - Heart rate in bpm */
  HEART_RATE = 17,
  /**
   * RGBC_LIGHT - Ambient RGBC light intensity. Values are in order (Red, Green, Blue,
   * Clear).
   */
  RGBC_LIGHT = 18,
  /** WRIST_TILT - Wrist tilt gesture (1 = gaze, 0 = ungaze) */
  WRIST_TILT = 19,
  UNRECOGNIZED = -1,
}

export function physicalModelValue_PhysicalTypeFromJSON(object: any): PhysicalModelValue_PhysicalType {
  switch (object) {
    case 0:
    case "POSITION":
      return PhysicalModelValue_PhysicalType.POSITION;
    case 1:
    case "ROTATION":
      return PhysicalModelValue_PhysicalType.ROTATION;
    case 2:
    case "MAGNETIC_FIELD":
      return PhysicalModelValue_PhysicalType.MAGNETIC_FIELD;
    case 3:
    case "TEMPERATURE":
      return PhysicalModelValue_PhysicalType.TEMPERATURE;
    case 4:
    case "PROXIMITY":
      return PhysicalModelValue_PhysicalType.PROXIMITY;
    case 5:
    case "LIGHT":
      return PhysicalModelValue_PhysicalType.LIGHT;
    case 6:
    case "PRESSURE":
      return PhysicalModelValue_PhysicalType.PRESSURE;
    case 7:
    case "HUMIDITY":
      return PhysicalModelValue_PhysicalType.HUMIDITY;
    case 8:
    case "VELOCITY":
      return PhysicalModelValue_PhysicalType.VELOCITY;
    case 9:
    case "AMBIENT_MOTION":
      return PhysicalModelValue_PhysicalType.AMBIENT_MOTION;
    case 10:
    case "HINGE_ANGLE0":
      return PhysicalModelValue_PhysicalType.HINGE_ANGLE0;
    case 11:
    case "HINGE_ANGLE1":
      return PhysicalModelValue_PhysicalType.HINGE_ANGLE1;
    case 12:
    case "HINGE_ANGLE2":
      return PhysicalModelValue_PhysicalType.HINGE_ANGLE2;
    case 13:
    case "ROLLABLE0":
      return PhysicalModelValue_PhysicalType.ROLLABLE0;
    case 14:
    case "ROLLABLE1":
      return PhysicalModelValue_PhysicalType.ROLLABLE1;
    case 15:
    case "ROLLABLE2":
      return PhysicalModelValue_PhysicalType.ROLLABLE2;
    case 16:
    case "POSTURE":
      return PhysicalModelValue_PhysicalType.POSTURE;
    case 17:
    case "HEART_RATE":
      return PhysicalModelValue_PhysicalType.HEART_RATE;
    case 18:
    case "RGBC_LIGHT":
      return PhysicalModelValue_PhysicalType.RGBC_LIGHT;
    case 19:
    case "WRIST_TILT":
      return PhysicalModelValue_PhysicalType.WRIST_TILT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PhysicalModelValue_PhysicalType.UNRECOGNIZED;
  }
}

export function physicalModelValue_PhysicalTypeToJSON(object: PhysicalModelValue_PhysicalType): string {
  switch (object) {
    case PhysicalModelValue_PhysicalType.POSITION:
      return "POSITION";
    case PhysicalModelValue_PhysicalType.ROTATION:
      return "ROTATION";
    case PhysicalModelValue_PhysicalType.MAGNETIC_FIELD:
      return "MAGNETIC_FIELD";
    case PhysicalModelValue_PhysicalType.TEMPERATURE:
      return "TEMPERATURE";
    case PhysicalModelValue_PhysicalType.PROXIMITY:
      return "PROXIMITY";
    case PhysicalModelValue_PhysicalType.LIGHT:
      return "LIGHT";
    case PhysicalModelValue_PhysicalType.PRESSURE:
      return "PRESSURE";
    case PhysicalModelValue_PhysicalType.HUMIDITY:
      return "HUMIDITY";
    case PhysicalModelValue_PhysicalType.VELOCITY:
      return "VELOCITY";
    case PhysicalModelValue_PhysicalType.AMBIENT_MOTION:
      return "AMBIENT_MOTION";
    case PhysicalModelValue_PhysicalType.HINGE_ANGLE0:
      return "HINGE_ANGLE0";
    case PhysicalModelValue_PhysicalType.HINGE_ANGLE1:
      return "HINGE_ANGLE1";
    case PhysicalModelValue_PhysicalType.HINGE_ANGLE2:
      return "HINGE_ANGLE2";
    case PhysicalModelValue_PhysicalType.ROLLABLE0:
      return "ROLLABLE0";
    case PhysicalModelValue_PhysicalType.ROLLABLE1:
      return "ROLLABLE1";
    case PhysicalModelValue_PhysicalType.ROLLABLE2:
      return "ROLLABLE2";
    case PhysicalModelValue_PhysicalType.POSTURE:
      return "POSTURE";
    case PhysicalModelValue_PhysicalType.HEART_RATE:
      return "HEART_RATE";
    case PhysicalModelValue_PhysicalType.RGBC_LIGHT:
      return "RGBC_LIGHT";
    case PhysicalModelValue_PhysicalType.WRIST_TILT:
      return "WRIST_TILT";
    case PhysicalModelValue_PhysicalType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A single sensor value. */
export interface SensorValue {
  /** Type of sensor */
  target: SensorValue_SensorType;
  /** [Output Only] */
  status: SensorValue_State;
  /** Value interpretation depends on sensor enum. */
  value: ParameterValue | undefined;
}

export enum SensorValue_State {
  OK = 0,
  /** NO_SERVICE - qemud service is not available/initiated. */
  NO_SERVICE = -3,
  /** DISABLED - Sensor is disabled. */
  DISABLED = -2,
  /** UNKNOWN - Unknown sensor (should not happen) */
  UNKNOWN = -1,
}

export function sensorValue_StateFromJSON(object: any): SensorValue_State {
  switch (object) {
    case 0:
    case "OK":
      return SensorValue_State.OK;
    case -3:
    case "NO_SERVICE":
      return SensorValue_State.NO_SERVICE;
    case -2:
    case "DISABLED":
      return SensorValue_State.DISABLED;
    case -1:
    case "UNKNOWN":
      return SensorValue_State.UNKNOWN;
    default:
      return SensorValue_State.UNKNOWN;
  }
}

export function sensorValue_StateToJSON(object: SensorValue_State): string {
  switch (object) {
    case SensorValue_State.OK:
      return "OK";
    case SensorValue_State.NO_SERVICE:
      return "NO_SERVICE";
    case SensorValue_State.DISABLED:
      return "DISABLED";
    case SensorValue_State.UNKNOWN:
      return "UNKNOWN";
    default:
      return "UNKNOWN";
  }
}

/**
 * These are the various sensors that can be available in an emulated
 * devices.
 */
export enum SensorValue_SensorType {
  /**
   * ACCELERATION - Measures the acceleration force in m/s2 that is applied to a device
   * on all three physical axes (x, y, and z), including the force of
   * gravity.
   */
  ACCELERATION = 0,
  /**
   * GYROSCOPE - Measures a device's rate of rotation in rad/s around each of the
   * three physical axes (x, y, and z).
   */
  GYROSCOPE = 1,
  /**
   * MAGNETIC_FIELD - Measures the ambient geomagnetic field for all three physical axes
   * (x, y, z) in μT.
   */
  MAGNETIC_FIELD = 2,
  /**
   * ORIENTATION - Measures degrees of rotation that a device makes around all three
   * physical axes (x, y, z)
   */
  ORIENTATION = 3,
  /** TEMPERATURE - Measures the temperature of the device in degrees Celsius (°C). */
  TEMPERATURE = 4,
  /**
   * PROXIMITY - Measures the proximity of an object in cm relative to the view screen
   * of a device. This sensor is typically used to determine whether a
   * handset is being held up to a person's ear.
   */
  PROXIMITY = 5,
  /** LIGHT - Measures the ambient light level (illumination) in lx. */
  LIGHT = 6,
  /** PRESSURE - Measures the ambient air pressure in hPa or mbar. */
  PRESSURE = 7,
  /** HUMIDITY - Measures the relative ambient humidity in percent (%). */
  HUMIDITY = 8,
  MAGNETIC_FIELD_UNCALIBRATED = 9,
  GYROSCOPE_UNCALIBRATED = 10,
  /**
   * HEART_RATE - HINGE_ANGLE0 (11), HINGE_ANGLE1 (12), HINGE_ANGLE2 (13) are
   * skipped; clients should use get/setPhysicalModel() instead for these
   * "sensors".
   * Measures the heart rate in bpm.
   */
  HEART_RATE = 14,
  /**
   * RGBC_LIGHT - Measures the ambient RGBC light intensity.
   * Values are in order (Red, Green, Blue, Clear).
   */
  RGBC_LIGHT = 15,
  /**
   * ACCELERATION_UNCALIBRATED - WIRST_TILT (16) is skipped; clients should use get/setPhysicalModel()
   * instead.
   * Measures acceleration force and provides bias data.
   */
  ACCELERATION_UNCALIBRATED = 17,
  UNRECOGNIZED = -1,
}

export function sensorValue_SensorTypeFromJSON(object: any): SensorValue_SensorType {
  switch (object) {
    case 0:
    case "ACCELERATION":
      return SensorValue_SensorType.ACCELERATION;
    case 1:
    case "GYROSCOPE":
      return SensorValue_SensorType.GYROSCOPE;
    case 2:
    case "MAGNETIC_FIELD":
      return SensorValue_SensorType.MAGNETIC_FIELD;
    case 3:
    case "ORIENTATION":
      return SensorValue_SensorType.ORIENTATION;
    case 4:
    case "TEMPERATURE":
      return SensorValue_SensorType.TEMPERATURE;
    case 5:
    case "PROXIMITY":
      return SensorValue_SensorType.PROXIMITY;
    case 6:
    case "LIGHT":
      return SensorValue_SensorType.LIGHT;
    case 7:
    case "PRESSURE":
      return SensorValue_SensorType.PRESSURE;
    case 8:
    case "HUMIDITY":
      return SensorValue_SensorType.HUMIDITY;
    case 9:
    case "MAGNETIC_FIELD_UNCALIBRATED":
      return SensorValue_SensorType.MAGNETIC_FIELD_UNCALIBRATED;
    case 10:
    case "GYROSCOPE_UNCALIBRATED":
      return SensorValue_SensorType.GYROSCOPE_UNCALIBRATED;
    case 14:
    case "HEART_RATE":
      return SensorValue_SensorType.HEART_RATE;
    case 15:
    case "RGBC_LIGHT":
      return SensorValue_SensorType.RGBC_LIGHT;
    case 17:
    case "ACCELERATION_UNCALIBRATED":
      return SensorValue_SensorType.ACCELERATION_UNCALIBRATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SensorValue_SensorType.UNRECOGNIZED;
  }
}

export function sensorValue_SensorTypeToJSON(object: SensorValue_SensorType): string {
  switch (object) {
    case SensorValue_SensorType.ACCELERATION:
      return "ACCELERATION";
    case SensorValue_SensorType.GYROSCOPE:
      return "GYROSCOPE";
    case SensorValue_SensorType.MAGNETIC_FIELD:
      return "MAGNETIC_FIELD";
    case SensorValue_SensorType.ORIENTATION:
      return "ORIENTATION";
    case SensorValue_SensorType.TEMPERATURE:
      return "TEMPERATURE";
    case SensorValue_SensorType.PROXIMITY:
      return "PROXIMITY";
    case SensorValue_SensorType.LIGHT:
      return "LIGHT";
    case SensorValue_SensorType.PRESSURE:
      return "PRESSURE";
    case SensorValue_SensorType.HUMIDITY:
      return "HUMIDITY";
    case SensorValue_SensorType.MAGNETIC_FIELD_UNCALIBRATED:
      return "MAGNETIC_FIELD_UNCALIBRATED";
    case SensorValue_SensorType.GYROSCOPE_UNCALIBRATED:
      return "GYROSCOPE_UNCALIBRATED";
    case SensorValue_SensorType.HEART_RATE:
      return "HEART_RATE";
    case SensorValue_SensorType.RGBC_LIGHT:
      return "RGBC_LIGHT";
    case SensorValue_SensorType.ACCELERATION_UNCALIBRATED:
      return "ACCELERATION_UNCALIBRATED";
    case SensorValue_SensorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A single backlight brightness value. */
export interface BrightnessValue {
  /** Type of light */
  target: BrightnessValue_LightType;
  /** Light intensity, ranges from 0-255. */
  value: number;
}

export enum BrightnessValue_LightType {
  /** LCD - Display backlight. This will affect all displays. */
  LCD = 0,
  KEYBOARD = 1,
  BUTTON = 2,
  UNRECOGNIZED = -1,
}

export function brightnessValue_LightTypeFromJSON(object: any): BrightnessValue_LightType {
  switch (object) {
    case 0:
    case "LCD":
      return BrightnessValue_LightType.LCD;
    case 1:
    case "KEYBOARD":
      return BrightnessValue_LightType.KEYBOARD;
    case 2:
    case "BUTTON":
      return BrightnessValue_LightType.BUTTON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BrightnessValue_LightType.UNRECOGNIZED;
  }
}

export function brightnessValue_LightTypeToJSON(object: BrightnessValue_LightType): string {
  switch (object) {
    case BrightnessValue_LightType.LCD:
      return "LCD";
    case BrightnessValue_LightType.KEYBOARD:
      return "KEYBOARD";
    case BrightnessValue_LightType.BUTTON:
      return "BUTTON";
    case BrightnessValue_LightType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DisplayMode {
  value: DisplayModeValue;
}

export interface LogMessage {
  /** [Output Only] The contents of the log output. */
  contents: string;
  /**
   * The starting byte position of the output that was returned. This
   * should match the start parameter sent with the request. If the serial
   * console output exceeds the size of the buffer, older output will be
   * overwritten by newer content and the start values will be mismatched.
   *
   * @deprecated
   */
  start: number;
  /**
   * [Output Only] The position of the next byte of content from the serial
   * console output. Use this value in the next request as the start
   * parameter.
   *
   * @deprecated
   */
  next: number;
  /**
   * Set the sort of response you are interested it in.
   * It the type is "Parsed" the entries field will contain the parsed
   * results. otherwise the contents field will be set.
   */
  sort: LogMessage_LogType;
  /**
   * [Output Only] The parsed logcat entries so far. Only set if sort is
   * set to Parsed
   */
  entries: LogcatEntry[];
}

export enum LogMessage_LogType {
  Text = 0,
  Parsed = 1,
  UNRECOGNIZED = -1,
}

export function logMessage_LogTypeFromJSON(object: any): LogMessage_LogType {
  switch (object) {
    case 0:
    case "Text":
      return LogMessage_LogType.Text;
    case 1:
    case "Parsed":
      return LogMessage_LogType.Parsed;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LogMessage_LogType.UNRECOGNIZED;
  }
}

export function logMessage_LogTypeToJSON(object: LogMessage_LogType): string {
  switch (object) {
    case LogMessage_LogType.Text:
      return "Text";
    case LogMessage_LogType.Parsed:
      return "Parsed";
    case LogMessage_LogType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A parsed logcat entry. */
export interface LogcatEntry {
  /**
   * A Unix timestamps in  milliseconds (The number of milliseconds that
   * have elapsed since January 1, 1970 (midnight UTC/GMT), not counting
   * leap seconds)
   */
  timestamp: number;
  /** Process id. */
  pid: number;
  /** Thread id. */
  tid: number;
  level: LogcatEntry_LogLevel;
  tag: string;
  msg: string;
}

/** The possible log levels. */
export enum LogcatEntry_LogLevel {
  UNKNOWN = 0,
  DEFAULT = 1,
  VERBOSE = 2,
  DEBUG = 3,
  INFO = 4,
  WARN = 5,
  ERR = 6,
  FATAL = 7,
  SILENT = 8,
  UNRECOGNIZED = -1,
}

export function logcatEntry_LogLevelFromJSON(object: any): LogcatEntry_LogLevel {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return LogcatEntry_LogLevel.UNKNOWN;
    case 1:
    case "DEFAULT":
      return LogcatEntry_LogLevel.DEFAULT;
    case 2:
    case "VERBOSE":
      return LogcatEntry_LogLevel.VERBOSE;
    case 3:
    case "DEBUG":
      return LogcatEntry_LogLevel.DEBUG;
    case 4:
    case "INFO":
      return LogcatEntry_LogLevel.INFO;
    case 5:
    case "WARN":
      return LogcatEntry_LogLevel.WARN;
    case 6:
    case "ERR":
      return LogcatEntry_LogLevel.ERR;
    case 7:
    case "FATAL":
      return LogcatEntry_LogLevel.FATAL;
    case 8:
    case "SILENT":
      return LogcatEntry_LogLevel.SILENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LogcatEntry_LogLevel.UNRECOGNIZED;
  }
}

export function logcatEntry_LogLevelToJSON(object: LogcatEntry_LogLevel): string {
  switch (object) {
    case LogcatEntry_LogLevel.UNKNOWN:
      return "UNKNOWN";
    case LogcatEntry_LogLevel.DEFAULT:
      return "DEFAULT";
    case LogcatEntry_LogLevel.VERBOSE:
      return "VERBOSE";
    case LogcatEntry_LogLevel.DEBUG:
      return "DEBUG";
    case LogcatEntry_LogLevel.INFO:
      return "INFO";
    case LogcatEntry_LogLevel.WARN:
      return "WARN";
    case LogcatEntry_LogLevel.ERR:
      return "ERR";
    case LogcatEntry_LogLevel.FATAL:
      return "FATAL";
    case LogcatEntry_LogLevel.SILENT:
      return "SILENT";
    case LogcatEntry_LogLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information about the hypervisor that is currently in use. */
export interface VmConfiguration {
  hypervisorType: VmConfiguration_VmHypervisorType;
  numberOfCpuCores: number;
  ramSizeBytes: number;
}

export enum VmConfiguration_VmHypervisorType {
  /** UNKNOWN - An unknown hypervisor */
  UNKNOWN = 0,
  /**
   * NONE - No hypervisor is in use. This usually means that the guest is
   * running on a different CPU than the host, or you are using a
   * platform where no hypervisor is available.
   */
  NONE = 1,
  /**
   * KVM - The Kernel based Virtual Machine
   * (https://www.linux-kvm.org/page/Main_Page)
   */
  KVM = 2,
  /**
   * HAXM - Intel® Hardware Accelerated Execution Manager (Intel® HAXM)
   * https://github.com/intel/haxm
   */
  HAXM = 3,
  /**
   * HVF - Hypervisor Framework.
   * https://developer.apple.com/documentation/hypervisor
   */
  HVF = 4,
  /**
   * WHPX - Window Hypervisor Platform
   * https://docs.microsoft.com/en-us/virtualization/api/
   */
  WHPX = 5,
  AEHD = 6,
  UNRECOGNIZED = -1,
}

export function vmConfiguration_VmHypervisorTypeFromJSON(object: any): VmConfiguration_VmHypervisorType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return VmConfiguration_VmHypervisorType.UNKNOWN;
    case 1:
    case "NONE":
      return VmConfiguration_VmHypervisorType.NONE;
    case 2:
    case "KVM":
      return VmConfiguration_VmHypervisorType.KVM;
    case 3:
    case "HAXM":
      return VmConfiguration_VmHypervisorType.HAXM;
    case 4:
    case "HVF":
      return VmConfiguration_VmHypervisorType.HVF;
    case 5:
    case "WHPX":
      return VmConfiguration_VmHypervisorType.WHPX;
    case 6:
    case "AEHD":
      return VmConfiguration_VmHypervisorType.AEHD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VmConfiguration_VmHypervisorType.UNRECOGNIZED;
  }
}

export function vmConfiguration_VmHypervisorTypeToJSON(object: VmConfiguration_VmHypervisorType): string {
  switch (object) {
    case VmConfiguration_VmHypervisorType.UNKNOWN:
      return "UNKNOWN";
    case VmConfiguration_VmHypervisorType.NONE:
      return "NONE";
    case VmConfiguration_VmHypervisorType.KVM:
      return "KVM";
    case VmConfiguration_VmHypervisorType.HAXM:
      return "HAXM";
    case VmConfiguration_VmHypervisorType.HVF:
      return "HVF";
    case VmConfiguration_VmHypervisorType.WHPX:
      return "WHPX";
    case VmConfiguration_VmHypervisorType.AEHD:
      return "AEHD";
    case VmConfiguration_VmHypervisorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Representation of a clipped data object on the clipboard. */
export interface ClipData {
  /** UTF-8 Encoded text. */
  text: string;
}

/**
 * The Touch interface represents a single contact point on a
 * touch-sensitive device. The contact point is commonly a finger or stylus
 * and the device may be a touchscreen or trackpad.
 */
export interface Touch {
  /**
   * The horizontal coordinate. This is the physical location on the
   * screen For example 0 indicates the leftmost coordinate.
   */
  x: number;
  /**
   * The vertical coordinate. This is the physical location on the screen
   * For example 0 indicates the top left coordinate.
   */
  y: number;
  /**
   * The identifier is an arbitrary non-negative integer that is used to
   * identify and track each tool independently when multiple tools are
   * active. For example, when multiple fingers are touching the device,
   * each finger should be assigned a distinct tracking id that is used as
   * long as the finger remains in contact. Tracking ids may be reused
   * when their associated tools move out of range.
   *
   * The emulator currently supports up to 10 concurrent touch events. The
   * identifier can be any uninque value and will be mapped to the next
   * available internal identifier.
   */
  identifier: number;
  /**
   * Reports the physical pressure applied to the tip of the tool or the
   * signal strength of the touch contact.
   *
   * The values reported must be non-zero when the tool is touching the
   * device and zero otherwise to indicate that the touch event is
   * completed.
   *
   * Make sure to deliver a pressure of 0 for the given identifier when
   * the touch event is completed, otherwise the touch identifier will not
   * be unregistered!
   */
  pressure: number;
  /**
   * Optionally reports the cross-sectional area of the touch contact, or
   * the length of the longer dimension of the touch contact.
   */
  touchMajor: number;
  /**
   * Optionally reports the length of the shorter dimension of the touch
   * contact. This axis will be ignored if touch_major is reporting an
   * area measurement greater than 0.
   */
  touchMinor: number;
  expiration: Touch_EventExpiration;
  /** The orientation of the contact, if any. */
  orientation: number;
}

export enum Touch_EventExpiration {
  /**
   * EVENT_EXPIRATION_UNSPECIFIED - The system will use the default time of 120s to track
   * the touch event with the given identifier. If no update happens
   * within this timeframe the identifier is considered expired
   * and can be made available for re-use. This means that a touch event
   * with pressure 0 for this identifier will be send to the emulator.
   */
  EVENT_EXPIRATION_UNSPECIFIED = 0,
  /**
   * NEVER_EXPIRE - Never expire the given slot. You must *ALWAYS* close the identifier
   * by sending a touch event with 0 pressure.
   */
  NEVER_EXPIRE = 1,
  UNRECOGNIZED = -1,
}

export function touch_EventExpirationFromJSON(object: any): Touch_EventExpiration {
  switch (object) {
    case 0:
    case "EVENT_EXPIRATION_UNSPECIFIED":
      return Touch_EventExpiration.EVENT_EXPIRATION_UNSPECIFIED;
    case 1:
    case "NEVER_EXPIRE":
      return Touch_EventExpiration.NEVER_EXPIRE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Touch_EventExpiration.UNRECOGNIZED;
  }
}

export function touch_EventExpirationToJSON(object: Touch_EventExpiration): string {
  switch (object) {
    case Touch_EventExpiration.EVENT_EXPIRATION_UNSPECIFIED:
      return "EVENT_EXPIRATION_UNSPECIFIED";
    case Touch_EventExpiration.NEVER_EXPIRE:
      return "NEVER_EXPIRE";
    case Touch_EventExpiration.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A Pen is similar to a touch, with the addition
 * of button and rubber information.
 */
export interface Pen {
  location:
    | Touch
    | undefined;
  /** True if the button is pressed or not */
  buttonPressed: boolean;
  /** True if it is a rubber pointer. */
  rubberPointer: boolean;
}

/**
 * A TouchEvent contains a list of Touch objects that are in contact with
 * the touch surface.
 *
 * Touch events are delivered in sequence as specified in the touchList.
 *
 * TouchEvents are delivered to the emulated devices using ["Protocol
 * B"](https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt)
 */
export interface TouchEvent {
  /** The list of Touch objects, note that these do not need to be unique */
  touches: Touch[];
  /**
   * The display device where the touch event occurred.
   * Omitting or using the value 0 indicates the main display.
   */
  display: number;
}

export interface PenEvent {
  /** The list of Pen objects, note that these do not need to be unique */
  events: Pen[];
  /**
   * The display device where the pen event occurred.
   * Omitting or using the value 0 indicates the main display.
   */
  display: number;
}

/**
 * The MouseEvent interface represents events that occur due to the user
 * interacting with a pointing device (such as a mouse).
 */
export interface MouseEvent {
  /**
   * The horizontal coordinate. This is the physical location on the
   * screen For example 0 indicates the leftmost coordinate.
   */
  x: number;
  /**
   * The vertical coordinate. This is the physical location on the screen
   * For example 0 indicates the top left coordinate.
   */
  y: number;
  /**
   * Indicates which buttons are pressed.
   * 0: No button was pressed
   * 1: Primary button (left)
   * 2: Secondary button (right)
   */
  buttons: number;
  /**
   * The display device where the mouse event occurred.
   * Omitting or using the value 0 indicates the main display.
   */
  display: number;
}

export interface WheelEvent {
  /**
   * The value indicating how much the mouse wheel is rotated. Scaled so that
   * 120 equals to 1 wheel click. (120 is chosen as a multiplier often used to
   * represent wheel movements less than 1 wheel click. e.g.
   * https://doc.qt.io/qt-5/qwheelevent.html#angleDelta) Positive delta value
   * is assigned to dx when the top of wheel is moved to left. Similarly
   * positive delta value is assigned to dy when the top of wheel is moved
   * away from the user.
   */
  dx: number;
  dy: number;
  /**
   * The display device where the mouse event occurred.
   * Omitting or using the value 0 indicates the main display.
   */
  display: number;
}

/**
 * KeyboardEvent objects describe a user interaction with the keyboard; each
 * event describes a single interaction between the user and a key (or
 * combination of a key with modifier keys) on the keyboard.
 * This follows the pattern as set by
 * (javascript)[https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent]
 *
 * Note: that only keyCode, key, or text can be set and that the semantics
 * will slightly vary.
 */
export interface KeyboardEvent {
  /** Type of keycode contained in the keyCode field. */
  codeType: KeyboardEvent_KeyCodeType;
  /** The type of keyboard event that should be sent to the emulator */
  eventType: KeyboardEvent_KeyEventType;
  /**
   * This property represents a physical key on the keyboard (as opposed
   * to the character generated by pressing the key). In other words, this
   * property is a value which isn't altered by keyboard layout or the
   * state of the modifier keys. This value will be interpreted by the
   * emulator depending on the KeyCodeType. The incoming key code will be
   * translated to an evdev code type and send to the emulator.
   * The values in key and text will be ignored.
   */
  keyCode: number;
  /**
   * The value of the key pressed by the user, taking into consideration
   * the state of modifier keys such as Shift as well as the keyboard
   * locale and layout. This follows the w3c standard used in browsers.
   * You can find an accurate description of valid values
   * [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)
   *
   * Note that some keys can result in multiple evdev events that are
   * delivered to the emulator. for example the Key "A" will result in a
   * sequence:
   * ["Shift", "a"] -> [0x2a, 0x1e] whereas "a" results in ["a"] -> [0x1e].
   *
   * Not all documented keys are understood by android, and only printable
   * ASCII [32-127) characters are properly translated.
   *
   * Keep in mind that there are a set of key values that result in android
   * specific behavior
   * [see](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values#Phone_keys):
   *
   * - "AppSwitch": Behaves as the "Overview" button in android.
   * - "GoBack": The Back button.
   * - "GoHome": The Home button, which takes the user to the phone's main
   *             screen (usually an application launcher).
   * - "Power":  The Power button.
   */
  key: string;
  /**
   * Series of utf8 encoded characters to send to the emulator. An attempt
   * will be made to translate every character will an EvDev event type and
   * send to the emulator as a keypress event. The values in keyCode,
   * eventType, codeType and key will be ignored.
   *
   * Note that most printable ASCII characters (range [32-127) can be send
   * individually with the "key" param. Do not expect arbitrary UTF symbols to
   * arrive in the emulator (most will be ignored).
   *
   * Note that it is possible to overrun the keyboard buffer by slamming this
   * endpoint with large quantities of text (>1kb). The clipboard api is
   * better suited for transferring large quantities of text.
   */
  text: string;
}

/**
 * Code types that the emulator can receive. Note that the emulator
 * will do its best to translate the code to an evdev value that
 * will be send to the emulator. This translation is based on
 * the chromium translation tables. See
 * (this)[https://android.googlesource.com/platform/external/qemu/+/refs/heads/emu-master-dev/android/android-grpc/android/emulation/control/keyboard/keycode_converter_data.inc]
 * for details on the translation.
 */
export enum KeyboardEvent_KeyCodeType {
  Usb = 0,
  Evdev = 1,
  XKB = 2,
  Win = 3,
  Mac = 4,
  UNRECOGNIZED = -1,
}

export function keyboardEvent_KeyCodeTypeFromJSON(object: any): KeyboardEvent_KeyCodeType {
  switch (object) {
    case 0:
    case "Usb":
      return KeyboardEvent_KeyCodeType.Usb;
    case 1:
    case "Evdev":
      return KeyboardEvent_KeyCodeType.Evdev;
    case 2:
    case "XKB":
      return KeyboardEvent_KeyCodeType.XKB;
    case 3:
    case "Win":
      return KeyboardEvent_KeyCodeType.Win;
    case 4:
    case "Mac":
      return KeyboardEvent_KeyCodeType.Mac;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KeyboardEvent_KeyCodeType.UNRECOGNIZED;
  }
}

export function keyboardEvent_KeyCodeTypeToJSON(object: KeyboardEvent_KeyCodeType): string {
  switch (object) {
    case KeyboardEvent_KeyCodeType.Usb:
      return "Usb";
    case KeyboardEvent_KeyCodeType.Evdev:
      return "Evdev";
    case KeyboardEvent_KeyCodeType.XKB:
      return "XKB";
    case KeyboardEvent_KeyCodeType.Win:
      return "Win";
    case KeyboardEvent_KeyCodeType.Mac:
      return "Mac";
    case KeyboardEvent_KeyCodeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum KeyboardEvent_KeyEventType {
  /**
   * keydown - Indicates that this keyevent should be send to the emulator
   * as a key down event. Meaning that the key event will be
   * translated to an EvDev event type and bit 11 (0x400) will be
   * set before it is sent to the emulator.
   */
  keydown = 0,
  /**
   * keyup - Indicates that the keyevent should be send to the emulator
   * as a key up event. Meaning that the key event will be
   * translated to an EvDev event type and
   * sent to the emulator.
   */
  keyup = 1,
  /**
   * keypress - Indicates that the keyevent will be send to the emulator
   * as e key down event and immediately followed by a keyup event.
   */
  keypress = 2,
  UNRECOGNIZED = -1,
}

export function keyboardEvent_KeyEventTypeFromJSON(object: any): KeyboardEvent_KeyEventType {
  switch (object) {
    case 0:
    case "keydown":
      return KeyboardEvent_KeyEventType.keydown;
    case 1:
    case "keyup":
      return KeyboardEvent_KeyEventType.keyup;
    case 2:
    case "keypress":
      return KeyboardEvent_KeyEventType.keypress;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KeyboardEvent_KeyEventType.UNRECOGNIZED;
  }
}

export function keyboardEvent_KeyEventTypeToJSON(object: KeyboardEvent_KeyEventType): string {
  switch (object) {
    case KeyboardEvent_KeyEventType.keydown:
      return "keydown";
    case KeyboardEvent_KeyEventType.keyup:
      return "keyup";
    case KeyboardEvent_KeyEventType.keypress:
      return "keypress";
    case KeyboardEvent_KeyEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An input event that can be delivered to the emulator. */
export interface InputEvent {
  keyEvent?: KeyboardEvent | undefined;
  touchEvent?: TouchEvent | undefined;
  mouseEvent?: MouseEvent | undefined;
  androidEvent?: AndroidEvent | undefined;
  penEvent?: PenEvent | undefined;
  wheelEvent?: WheelEvent | undefined;
}

/**
 * The android input event system is a framework for handling input from a
 * variety of devices by generating events that describe changes in the
 * state of the devices and forwarding them to user space applications.
 *
 * An AndroidEvents will be delivered directly to the kernel as is.
 */
export interface AndroidEvent {
  /**
   * The type of the event. The types of the event are specified
   * by the android kernel. Some examples are:
   * EV_SYN, EV_KEY, EV_SW, etc..
   * The exact definitions can be found in the input.h header file.
   */
  type: number;
  /**
   * The actual code to be send to the kernel. The actual meaning
   * of the code depends on the type definition.
   */
  code: number;
  /** The actual value of the event. */
  value: number;
  /** The display id associated with this input event. */
  display: number;
}

export interface Fingerprint {
  /** True when the fingprint is touched. */
  isTouching: boolean;
  /** The identifier of the registered fingerprint. */
  touchId: number;
}

export interface GpsState {
  /**
   * Setting this to false will disable auto updating  from the LocationUI,
   * otherwise the location UI will override the location at a frequency of
   * 1hz.
   *
   * - This is unused if the emulator is launched with -no-window, or when he
   *   location ui is disabled.
   * - This will BREAK the location ui experience if it is set to false. For
   *    example routing will no longer function.
   */
  passiveUpdate: boolean;
  /** The latitude, in degrees. */
  latitude: number;
  /** The longitude, in degrees. */
  longitude: number;
  /** The speed if it is available, in meters/second over ground */
  speed: number;
  /**
   * gets the horizontal direction of travel of this device, and is not
   * related to the device orientation. It is guaranteed to be in the
   * range [0.0, 360.0] if the device has a bearing. 0=North, 90=East,
   * 180=South, etc..
   */
  bearing: number;
  /**
   * The altitude if available, in meters above the WGS 84 reference
   * ellipsoid.
   */
  altitude: number;
  /** The number of satellites used to derive the fix */
  satellites: number;
}

export interface BatteryState {
  hasBattery: boolean;
  isPresent: boolean;
  charger: BatteryState_BatteryCharger;
  chargeLevel: number;
  health: BatteryState_BatteryHealth;
  status: BatteryState_BatteryStatus;
}

export enum BatteryState_BatteryStatus {
  UNKNOWN = 0,
  CHARGING = 1,
  DISCHARGING = 2,
  NOT_CHARGING = 3,
  FULL = 4,
  UNRECOGNIZED = -1,
}

export function batteryState_BatteryStatusFromJSON(object: any): BatteryState_BatteryStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return BatteryState_BatteryStatus.UNKNOWN;
    case 1:
    case "CHARGING":
      return BatteryState_BatteryStatus.CHARGING;
    case 2:
    case "DISCHARGING":
      return BatteryState_BatteryStatus.DISCHARGING;
    case 3:
    case "NOT_CHARGING":
      return BatteryState_BatteryStatus.NOT_CHARGING;
    case 4:
    case "FULL":
      return BatteryState_BatteryStatus.FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BatteryState_BatteryStatus.UNRECOGNIZED;
  }
}

export function batteryState_BatteryStatusToJSON(object: BatteryState_BatteryStatus): string {
  switch (object) {
    case BatteryState_BatteryStatus.UNKNOWN:
      return "UNKNOWN";
    case BatteryState_BatteryStatus.CHARGING:
      return "CHARGING";
    case BatteryState_BatteryStatus.DISCHARGING:
      return "DISCHARGING";
    case BatteryState_BatteryStatus.NOT_CHARGING:
      return "NOT_CHARGING";
    case BatteryState_BatteryStatus.FULL:
      return "FULL";
    case BatteryState_BatteryStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BatteryState_BatteryCharger {
  NONE = 0,
  AC = 1,
  USB = 2,
  WIRELESS = 3,
  UNRECOGNIZED = -1,
}

export function batteryState_BatteryChargerFromJSON(object: any): BatteryState_BatteryCharger {
  switch (object) {
    case 0:
    case "NONE":
      return BatteryState_BatteryCharger.NONE;
    case 1:
    case "AC":
      return BatteryState_BatteryCharger.AC;
    case 2:
    case "USB":
      return BatteryState_BatteryCharger.USB;
    case 3:
    case "WIRELESS":
      return BatteryState_BatteryCharger.WIRELESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BatteryState_BatteryCharger.UNRECOGNIZED;
  }
}

export function batteryState_BatteryChargerToJSON(object: BatteryState_BatteryCharger): string {
  switch (object) {
    case BatteryState_BatteryCharger.NONE:
      return "NONE";
    case BatteryState_BatteryCharger.AC:
      return "AC";
    case BatteryState_BatteryCharger.USB:
      return "USB";
    case BatteryState_BatteryCharger.WIRELESS:
      return "WIRELESS";
    case BatteryState_BatteryCharger.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BatteryState_BatteryHealth {
  GOOD = 0,
  FAILED = 1,
  DEAD = 2,
  OVERVOLTAGE = 3,
  OVERHEATED = 4,
  UNRECOGNIZED = -1,
}

export function batteryState_BatteryHealthFromJSON(object: any): BatteryState_BatteryHealth {
  switch (object) {
    case 0:
    case "GOOD":
      return BatteryState_BatteryHealth.GOOD;
    case 1:
    case "FAILED":
      return BatteryState_BatteryHealth.FAILED;
    case 2:
    case "DEAD":
      return BatteryState_BatteryHealth.DEAD;
    case 3:
    case "OVERVOLTAGE":
      return BatteryState_BatteryHealth.OVERVOLTAGE;
    case 4:
    case "OVERHEATED":
      return BatteryState_BatteryHealth.OVERHEATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BatteryState_BatteryHealth.UNRECOGNIZED;
  }
}

export function batteryState_BatteryHealthToJSON(object: BatteryState_BatteryHealth): string {
  switch (object) {
    case BatteryState_BatteryHealth.GOOD:
      return "GOOD";
    case BatteryState_BatteryHealth.FAILED:
      return "FAILED";
    case BatteryState_BatteryHealth.DEAD:
      return "DEAD";
    case BatteryState_BatteryHealth.OVERVOLTAGE:
      return "OVERVOLTAGE";
    case BatteryState_BatteryHealth.OVERHEATED:
      return "OVERHEATED";
    case BatteryState_BatteryHealth.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An ImageTransport allows for specifying a side channel for
 * delivering image frames versus using the standard bytes array that is
 * returned with the gRPC request.
 */
export interface ImageTransport {
  /**
   * The desired transport channel used for delivering image frames. Only
   * relevant when streaming screenshots.
   */
  channel: ImageTransport_TransportChannel;
  /**
   * Handle used for writing image frames if transport is mmap. The client
   * sets and owns this handle. It can be either a shm region, or a mmap. A
   * mmap should be a url that starts with `file:///` Note: the mmap can
   * result in tearing.
   */
  handle: string;
}

export enum ImageTransport_TransportChannel {
  /** TRANSPORT_CHANNEL_UNSPECIFIED - Return full frames over the gRPC transport */
  TRANSPORT_CHANNEL_UNSPECIFIED = 0,
  /** MMAP - Write images to the a file/shared memory handle. */
  MMAP = 1,
  UNRECOGNIZED = -1,
}

export function imageTransport_TransportChannelFromJSON(object: any): ImageTransport_TransportChannel {
  switch (object) {
    case 0:
    case "TRANSPORT_CHANNEL_UNSPECIFIED":
      return ImageTransport_TransportChannel.TRANSPORT_CHANNEL_UNSPECIFIED;
    case 1:
    case "MMAP":
      return ImageTransport_TransportChannel.MMAP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImageTransport_TransportChannel.UNRECOGNIZED;
  }
}

export function imageTransport_TransportChannelToJSON(object: ImageTransport_TransportChannel): string {
  switch (object) {
    case ImageTransport_TransportChannel.TRANSPORT_CHANNEL_UNSPECIFIED:
      return "TRANSPORT_CHANNEL_UNSPECIFIED";
    case ImageTransport_TransportChannel.MMAP:
      return "MMAP";
    case ImageTransport_TransportChannel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The aspect ratio (width/height) will be different from the one
 * where the device is unfolded.
 */
export interface FoldedDisplay {
  width: number;
  height: number;
  /**
   * It is possible for the screen to be folded in different ways depending
   * on which surface is shown to the user. So xOffset and yOffset indicate
   * the top left corner of the folded screen within the original unfolded
   * screen.
   */
  xOffset: number;
  yOffset: number;
}

export interface ImageFormat {
  /** The (desired) format of the resulting bytes. */
  format: ImageFormat_ImgFormat;
  /**
   * [Output Only] The rotation of the image. The image will be rotated
   * based upon the coarse grained orientation of the device.
   */
  rotation:
    | Rotation
    | undefined;
  /**
   * The (desired) width of the image. When passed as input
   * the image will be scaled to match the given
   * width, while maintaining the aspect ratio of the device.
   * The returned image will never exceed the given width, but can be less.
   * Omitting this value (or passing in 0) will result in no scaling,
   * and the width of the actual device will be used.
   */
  width: number;
  /**
   * The (desired) height of the image.  When passed as input
   * the image will be scaled to match the given
   * height, while maintaining the aspect ratio of the device.
   * The returned image will never exceed the given height, but can be less.
   * Omitting this value (or passing in 0) will result in no scaling,
   * and the height of the actual device will be used.
   */
  height: number;
  /**
   * The (desired) display id of the device. Setting this to 0 (or omitting)
   * indicates the main display.
   */
  display: number;
  /**
   * Set this if you wish to use a different transport channel to deliver
   * image frames.
   */
  transport:
    | ImageTransport
    | undefined;
  /**
   * [Output Only] Display configuration when screen is folded. The value is
   * the original configuration before scaling.
   */
  foldedDisplay:
    | FoldedDisplay
    | undefined;
  /** [Output Only] Display mode when AVD is resizable. */
  displayMode: DisplayModeValue;
}

export enum ImageFormat_ImgFormat {
  /**
   * PNG - Portable Network Graphics format
   * (https://en.wikipedia.org/wiki/Portable_Network_Graphics)
   */
  PNG = 0,
  /**
   * RGBA8888 - Three-channel RGB color model supplemented with a fourth alpha
   * channel. https://en.wikipedia.org/wiki/RGBA_color_model
   * Each pixel consists of 4 bytes.
   */
  RGBA8888 = 1,
  /** RGB888 - Three-channel RGB color model, each pixel consists of 3 bytes */
  RGB888 = 2,
  UNRECOGNIZED = -1,
}

export function imageFormat_ImgFormatFromJSON(object: any): ImageFormat_ImgFormat {
  switch (object) {
    case 0:
    case "PNG":
      return ImageFormat_ImgFormat.PNG;
    case 1:
    case "RGBA8888":
      return ImageFormat_ImgFormat.RGBA8888;
    case 2:
    case "RGB888":
      return ImageFormat_ImgFormat.RGB888;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImageFormat_ImgFormat.UNRECOGNIZED;
  }
}

export function imageFormat_ImgFormatToJSON(object: ImageFormat_ImgFormat): string {
  switch (object) {
    case ImageFormat_ImgFormat.PNG:
      return "PNG";
    case ImageFormat_ImgFormat.RGBA8888:
      return "RGBA8888";
    case ImageFormat_ImgFormat.RGB888:
      return "RGB888";
    case ImageFormat_ImgFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Image {
  format:
    | ImageFormat
    | undefined;
  /**
   * width is contained in format.
   *
   * @deprecated
   */
  width: number;
  /**
   * height is contained in format.
   *
   * @deprecated
   */
  height: number;
  /**
   * The organization of the pixels in the image buffer is from left to
   * right and bottom up. This will be empty if an alternative image transport
   * is requested in the image format. In that case the side channel should
   * be used to obtain the image data.
   */
  image: Uint8Array;
  /**
   * [Output Only] Monotonically increasing sequence number in a stream of
   * screenshots. The first screenshot will have a sequence of 0. A single
   * screenshot will always have a sequence number of 0. The sequence is not
   * necessarily contiguous, and can be used to detect how many frames were
   * dropped. An example sequence could be: [0, 3, 5, 7, 9, 11].
   */
  seq: number;
  /**
   * [Output Only] Unix timestamp in microseconds when the emulator estimates
   * the frame was generated. The timestamp is before the actual frame is
   * copied and transformed. This can be used to calculate variance between
   * frame production time, and frame depiction time.
   */
  timestampUs: number;
}

export interface Rotation {
  /**
   * The rotation of the device, derived from the sensor state
   * of the emulator. The derivation reflects how android observes
   * the rotation state.
   */
  rotation: Rotation_SkinRotation;
  /** Specifies the angle of rotation, in degrees [-180, 180] */
  xAxis: number;
  yAxis: number;
  zAxis: number;
}

export enum Rotation_SkinRotation {
  /** PORTRAIT - 0 degrees */
  PORTRAIT = 0,
  /** LANDSCAPE - 90 degrees */
  LANDSCAPE = 1,
  /** REVERSE_PORTRAIT - -180 degrees */
  REVERSE_PORTRAIT = 2,
  /** REVERSE_LANDSCAPE - -90 degrees */
  REVERSE_LANDSCAPE = 3,
  UNRECOGNIZED = -1,
}

export function rotation_SkinRotationFromJSON(object: any): Rotation_SkinRotation {
  switch (object) {
    case 0:
    case "PORTRAIT":
      return Rotation_SkinRotation.PORTRAIT;
    case 1:
    case "LANDSCAPE":
      return Rotation_SkinRotation.LANDSCAPE;
    case 2:
    case "REVERSE_PORTRAIT":
      return Rotation_SkinRotation.REVERSE_PORTRAIT;
    case 3:
    case "REVERSE_LANDSCAPE":
      return Rotation_SkinRotation.REVERSE_LANDSCAPE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Rotation_SkinRotation.UNRECOGNIZED;
  }
}

export function rotation_SkinRotationToJSON(object: Rotation_SkinRotation): string {
  switch (object) {
    case Rotation_SkinRotation.PORTRAIT:
      return "PORTRAIT";
    case Rotation_SkinRotation.LANDSCAPE:
      return "LANDSCAPE";
    case Rotation_SkinRotation.REVERSE_PORTRAIT:
      return "REVERSE_PORTRAIT";
    case Rotation_SkinRotation.REVERSE_LANDSCAPE:
      return "REVERSE_LANDSCAPE";
    case Rotation_SkinRotation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PhoneCall {
  operation: PhoneCall_Operation;
  number: string;
}

export enum PhoneCall_Operation {
  InitCall = 0,
  AcceptCall = 1,
  RejectCallExplicit = 2,
  RejectCallBusy = 3,
  DisconnectCall = 4,
  PlaceCallOnHold = 5,
  TakeCallOffHold = 6,
  UNRECOGNIZED = -1,
}

export function phoneCall_OperationFromJSON(object: any): PhoneCall_Operation {
  switch (object) {
    case 0:
    case "InitCall":
      return PhoneCall_Operation.InitCall;
    case 1:
    case "AcceptCall":
      return PhoneCall_Operation.AcceptCall;
    case 2:
    case "RejectCallExplicit":
      return PhoneCall_Operation.RejectCallExplicit;
    case 3:
    case "RejectCallBusy":
      return PhoneCall_Operation.RejectCallBusy;
    case 4:
    case "DisconnectCall":
      return PhoneCall_Operation.DisconnectCall;
    case 5:
    case "PlaceCallOnHold":
      return PhoneCall_Operation.PlaceCallOnHold;
    case 6:
    case "TakeCallOffHold":
      return PhoneCall_Operation.TakeCallOffHold;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PhoneCall_Operation.UNRECOGNIZED;
  }
}

export function phoneCall_OperationToJSON(object: PhoneCall_Operation): string {
  switch (object) {
    case PhoneCall_Operation.InitCall:
      return "InitCall";
    case PhoneCall_Operation.AcceptCall:
      return "AcceptCall";
    case PhoneCall_Operation.RejectCallExplicit:
      return "RejectCallExplicit";
    case PhoneCall_Operation.RejectCallBusy:
      return "RejectCallBusy";
    case PhoneCall_Operation.DisconnectCall:
      return "DisconnectCall";
    case PhoneCall_Operation.PlaceCallOnHold:
      return "PlaceCallOnHold";
    case PhoneCall_Operation.TakeCallOffHold:
      return "TakeCallOffHold";
    case PhoneCall_Operation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PhoneResponse {
  response: PhoneResponse_Response;
}

export enum PhoneResponse_Response {
  OK = 0,
  /** BadOperation - Enum out of range */
  BadOperation = 1,
  /** BadNumber - Mal-formed telephone number */
  BadNumber = 2,
  /** InvalidAction - E.g., disconnect when no call is in progress */
  InvalidAction = 3,
  /** ActionFailed - Internal error */
  ActionFailed = 4,
  /** RadioOff - Radio power off */
  RadioOff = 5,
  UNRECOGNIZED = -1,
}

export function phoneResponse_ResponseFromJSON(object: any): PhoneResponse_Response {
  switch (object) {
    case 0:
    case "OK":
      return PhoneResponse_Response.OK;
    case 1:
    case "BadOperation":
      return PhoneResponse_Response.BadOperation;
    case 2:
    case "BadNumber":
      return PhoneResponse_Response.BadNumber;
    case 3:
    case "InvalidAction":
      return PhoneResponse_Response.InvalidAction;
    case 4:
    case "ActionFailed":
      return PhoneResponse_Response.ActionFailed;
    case 5:
    case "RadioOff":
      return PhoneResponse_Response.RadioOff;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PhoneResponse_Response.UNRECOGNIZED;
  }
}

export function phoneResponse_ResponseToJSON(object: PhoneResponse_Response): string {
  switch (object) {
    case PhoneResponse_Response.OK:
      return "OK";
    case PhoneResponse_Response.BadOperation:
      return "BadOperation";
    case PhoneResponse_Response.BadNumber:
      return "BadNumber";
    case PhoneResponse_Response.InvalidAction:
      return "InvalidAction";
    case PhoneResponse_Response.ActionFailed:
      return "ActionFailed";
    case PhoneResponse_Response.RadioOff:
      return "RadioOff";
    case PhoneResponse_Response.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Entry {
  key: string;
  value: string;
}

export interface EntryList {
  entry: Entry[];
}

export interface EmulatorStatus {
  /** The emulator version string. */
  version: string;
  /** The time the emulator has been active in .ms */
  uptime: number;
  /**
   * True if the device has completed booting.
   * For P and later this information will accurate,
   * for older images we rely on adb.
   */
  booted: boolean;
  /** The current vm configuration */
  vmConfig:
    | VmConfiguration
    | undefined;
  /**
   * The hardware configuration of the running emulator as
   * key valure pairs.
   */
  hardwareConfig:
    | EntryList
    | undefined;
  /**
   * Some guests will produce a heart beat, that can be used to
   * detect if the guest is active.
   * This is a monotonically increasing number that gets incremented
   * around once a second.
   */
  heartbeat: number;
  /**
   * The configuration of services in the guest, this map
   * contains key value pairs that are specific to the image
   * used by the guest.
   */
  guestConfig: { [key: string]: string };
}

export interface EmulatorStatus_GuestConfigEntry {
  key: string;
  value: string;
}

export interface AudioFormat {
  /**
   * Sampling rate to use, defaulting to 44100 if this is not set.
   * Note, that android devices typically will not use a sampling
   * rate higher than 48kHz. See
   * https://developer.android.com/ndk/guides/audio.
   */
  samplingRate: number;
  channels: AudioFormat_Channels;
  format: AudioFormat_SampleFormat;
  /**
   * [Input Only]
   * The mode used when delivering audio packets.
   */
  mode: AudioFormat_DeliveryMode;
}

export enum AudioFormat_SampleFormat {
  /** AUD_FMT_U8 - Unsigned 8 bit */
  AUD_FMT_U8 = 0,
  /** AUD_FMT_S16 - Signed 16 bit (little endian) */
  AUD_FMT_S16 = 1,
  UNRECOGNIZED = -1,
}

export function audioFormat_SampleFormatFromJSON(object: any): AudioFormat_SampleFormat {
  switch (object) {
    case 0:
    case "AUD_FMT_U8":
      return AudioFormat_SampleFormat.AUD_FMT_U8;
    case 1:
    case "AUD_FMT_S16":
      return AudioFormat_SampleFormat.AUD_FMT_S16;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AudioFormat_SampleFormat.UNRECOGNIZED;
  }
}

export function audioFormat_SampleFormatToJSON(object: AudioFormat_SampleFormat): string {
  switch (object) {
    case AudioFormat_SampleFormat.AUD_FMT_U8:
      return "AUD_FMT_U8";
    case AudioFormat_SampleFormat.AUD_FMT_S16:
      return "AUD_FMT_S16";
    case AudioFormat_SampleFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AudioFormat_Channels {
  Mono = 0,
  Stereo = 1,
  UNRECOGNIZED = -1,
}

export function audioFormat_ChannelsFromJSON(object: any): AudioFormat_Channels {
  switch (object) {
    case 0:
    case "Mono":
      return AudioFormat_Channels.Mono;
    case 1:
    case "Stereo":
      return AudioFormat_Channels.Stereo;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AudioFormat_Channels.UNRECOGNIZED;
  }
}

export function audioFormat_ChannelsToJSON(object: AudioFormat_Channels): string {
  switch (object) {
    case AudioFormat_Channels.Mono:
      return "Mono";
    case AudioFormat_Channels.Stereo:
      return "Stereo";
    case AudioFormat_Channels.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AudioFormat_DeliveryMode {
  /**
   * MODE_UNSPECIFIED - The audio queue will block and wait until the emulator requests
   * packets. The client does not have to throttle and can push packets at
   * will. This can result in the client falling behind.
   */
  MODE_UNSPECIFIED = 0,
  /**
   * MODE_REAL_TIME - Audio packets will be delivered in real time (when possible). The
   * audio queue will be overwritten with incoming data if data is made
   * available. This means the client needs to control timing properly, or
   * packets will get overwritten.
   */
  MODE_REAL_TIME = 1,
  UNRECOGNIZED = -1,
}

export function audioFormat_DeliveryModeFromJSON(object: any): AudioFormat_DeliveryMode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return AudioFormat_DeliveryMode.MODE_UNSPECIFIED;
    case 1:
    case "MODE_REAL_TIME":
      return AudioFormat_DeliveryMode.MODE_REAL_TIME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AudioFormat_DeliveryMode.UNRECOGNIZED;
  }
}

export function audioFormat_DeliveryModeToJSON(object: AudioFormat_DeliveryMode): string {
  switch (object) {
    case AudioFormat_DeliveryMode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case AudioFormat_DeliveryMode.MODE_REAL_TIME:
      return "MODE_REAL_TIME";
    case AudioFormat_DeliveryMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AudioPacket {
  format:
    | AudioFormat
    | undefined;
  /** Unix epoch in us when this frame was captured. */
  timestamp: number;
  /** Contains a sample in the given audio format. */
  audio: Uint8Array;
}

export interface SmsMessage {
  /**
   * The source address where this message came from.
   *
   * The address should be a valid GSM-formatted address as specified by
   * 3GPP 23.040 Sec 9.1.2.5.
   *
   * For example: +3106225412 or (650) 555-1221
   */
  srcAddress: string;
  /** A utf8 encoded text message that should be delivered. */
  text: string;
}

/**
 * A DisplayConfiguration describes a primary or secondary
 * display available to the emulator. The screen aspect ratio
 * cannot be longer (or wider) than 21:9 (or 9:21). Screen sizes
 * larger than 4k will be rejected.
 *
 * Common configurations (w x h) are:
 * - 480p  (480x720)   142 dpi
 * - 720p  (720x1280)  213 dpi
 * - 1080p (1080x1920) 320 dpi
 * - 4K  (2160x3840) 320 dpi
 * - 4K  (2160x3840) 640 dpi (upscaled)
 *
 * The behavior of the virtual display depends on the flags that are provided to
 * this method. By default, virtual displays are created to be private,
 * non-presentation and unsecure.
 */
export interface DisplayConfiguration {
  /**
   * The width of the display, restricted to:
   * 320 * (dpi / 160) <= width
   */
  width: number;
  /**
   * The heigh of the display, restricted to:
   * * 320 * (dpi / 160) <= height
   */
  height: number;
  /**
   * The pixel density (dpi).
   * See https://developer.android.com/training/multiscreen/screendensities
   * for details. This value should be in the range [120, ..., 640]
   */
  dpi: number;
  /**
   * A combination of virtual display flags. These flags can be constructed
   * by combining the DisplayFlags enum described above.
   *
   * The behavior of the virtual display depends on the flags. By default
   * virtual displays are created to be private, non-presentation and
   * unsecure.
   */
  flags: number;
  /**
   * The id of the display.
   * The primary (default) display has the display ID of 0.
   * A secondary display has a display ID not 0.
   *
   * A display with the id in the range [1, userConfigurable]
   * can be modified. See DisplayConfigurations below for details.
   *
   * The id can be used to get or stream a screenshot.
   */
  display: number;
}

/**
 * These are the set of known android flags and their respective values.
 * you can combine the int values to (de)construct the flags field below.
 */
export enum DisplayConfiguration_DisplayFlags {
  DISPLAYFLAGS_UNSPECIFIED = 0,
  /**
   * VIRTUAL_DISPLAY_FLAG_PUBLIC - When this flag is set, the virtual display is public.
   * A public virtual display behaves just like most any other display
   * that is connected to the system such as an external or wireless
   * display. Applications can open windows on the display and the system
   * may mirror the contents of other displays onto it. see:
   * https://developer.android.com/reference/android/hardware/display/DisplayManager#VIRTUAL_DISPLAY_FLAG_PUBLIC
   */
  VIRTUAL_DISPLAY_FLAG_PUBLIC = 1,
  /**
   * VIRTUAL_DISPLAY_FLAG_PRESENTATION - When this flag is set, the virtual display is registered as a
   * presentation display in the presentation display category.
   * Applications may automatically project their content to presentation
   * displays to provide richer second screen experiences.
   * https://developer.android.com/reference/android/hardware/display/DisplayManager#VIRTUAL_DISPLAY_FLAG_PRESENTATION
   */
  VIRTUAL_DISPLAY_FLAG_PRESENTATION = 2,
  /**
   * VIRTUAL_DISPLAY_FLAG_SECURE - When this flag is set, the virtual display is considered secure as
   * defined by the Display#FLAG_SECURE display flag. The caller promises
   * to take reasonable measures, such as over-the-air encryption, to
   * prevent the contents of the display from being intercepted or
   * recorded on a persistent medium.
   * see:
   * https://developer.android.com/reference/android/hardware/display/DisplayManager#VIRTUAL_DISPLAY_FLAG_SECURE
   */
  VIRTUAL_DISPLAY_FLAG_SECURE = 4,
  /**
   * VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY - This flag is used in conjunction with VIRTUAL_DISPLAY_FLAG_PUBLIC.
   * Ordinarily public virtual displays will automatically mirror the
   * content of the default display if they have no windows of their own.
   * When this flag is specified, the virtual display will only ever show
   * its own content and will be blanked instead if it has no windows. See
   * https://developer.android.com/reference/android/hardware/display/DisplayManager#VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY
   */
  VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY = 8,
  /**
   * VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR - Allows content to be mirrored on private displays when no content is
   * being shown.
   * This flag is mutually exclusive with
   * VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY. If both flags are specified
   * then the own-content only behavior will be applied.
   * see:
   * https://developer.android.com/reference/android/hardware/display/DisplayManager#VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR)
   */
  VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR = 16,
  UNRECOGNIZED = -1,
}

export function displayConfiguration_DisplayFlagsFromJSON(object: any): DisplayConfiguration_DisplayFlags {
  switch (object) {
    case 0:
    case "DISPLAYFLAGS_UNSPECIFIED":
      return DisplayConfiguration_DisplayFlags.DISPLAYFLAGS_UNSPECIFIED;
    case 1:
    case "VIRTUAL_DISPLAY_FLAG_PUBLIC":
      return DisplayConfiguration_DisplayFlags.VIRTUAL_DISPLAY_FLAG_PUBLIC;
    case 2:
    case "VIRTUAL_DISPLAY_FLAG_PRESENTATION":
      return DisplayConfiguration_DisplayFlags.VIRTUAL_DISPLAY_FLAG_PRESENTATION;
    case 4:
    case "VIRTUAL_DISPLAY_FLAG_SECURE":
      return DisplayConfiguration_DisplayFlags.VIRTUAL_DISPLAY_FLAG_SECURE;
    case 8:
    case "VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY":
      return DisplayConfiguration_DisplayFlags.VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY;
    case 16:
    case "VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR":
      return DisplayConfiguration_DisplayFlags.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DisplayConfiguration_DisplayFlags.UNRECOGNIZED;
  }
}

export function displayConfiguration_DisplayFlagsToJSON(object: DisplayConfiguration_DisplayFlags): string {
  switch (object) {
    case DisplayConfiguration_DisplayFlags.DISPLAYFLAGS_UNSPECIFIED:
      return "DISPLAYFLAGS_UNSPECIFIED";
    case DisplayConfiguration_DisplayFlags.VIRTUAL_DISPLAY_FLAG_PUBLIC:
      return "VIRTUAL_DISPLAY_FLAG_PUBLIC";
    case DisplayConfiguration_DisplayFlags.VIRTUAL_DISPLAY_FLAG_PRESENTATION:
      return "VIRTUAL_DISPLAY_FLAG_PRESENTATION";
    case DisplayConfiguration_DisplayFlags.VIRTUAL_DISPLAY_FLAG_SECURE:
      return "VIRTUAL_DISPLAY_FLAG_SECURE";
    case DisplayConfiguration_DisplayFlags.VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY:
      return "VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY";
    case DisplayConfiguration_DisplayFlags.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR:
      return "VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR";
    case DisplayConfiguration_DisplayFlags.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Provides information about all the displays that can be attached
 * to the emulator. The emulator will always have at least one display.
 *
 * The emulator usually has the following display configurations:
 * 0:      The default display.
 * 1 - 3:  User configurable displays. These can be added/removed.
 *         For example the standalone emulator allows you to modify these
 *         in the extended controls.
 * 6 - 11: Fixed external displays. For example Android Auto uses fixed
 *         displays in this range.
 */
export interface DisplayConfigurations {
  displays: DisplayConfiguration[];
  /**
   * Display configurations with id [1, userConfigurable] are
   * user configurable, that is they can be added, removed or
   * updated.
   */
  userConfigurable: number;
  /**
   * The maximum number of attached displays this emulator supports.
   * This is the total number of displays that can be attached to
   * the emulator.
   *
   * Note: A display with an id that is larger than userConfigurable cannot
   * be modified.
   */
  maxDisplays: number;
}

export interface Notification {
  /**
   * Deprecated, use the type below to get detailed information
   * regarding the event.
   *
   * @deprecated
   */
  event: Notification_EventType;
  cameraNotification?: CameraNotification | undefined;
  displayConfigurationsChangedNotification?: DisplayConfigurationsChangedNotification | undefined;
  posture?: Posture | undefined;
  booted?: BootCompletedNotification | undefined;
  brightness?: BrightnessValue | undefined;
}

export enum Notification_EventType {
  VIRTUAL_SCENE_CAMERA_INACTIVE = 0,
  VIRTUAL_SCENE_CAMERA_ACTIVE = 1,
  /**
   * DISPLAY_CONFIGURATIONS_CHANGED_UI - Fired when an update to a display event has been fired through
   * the extended ui. This does not fire events when the display
   * is changed through the console or gRPC endpoint.
   */
  DISPLAY_CONFIGURATIONS_CHANGED_UI = 2,
  UNRECOGNIZED = -1,
}

export function notification_EventTypeFromJSON(object: any): Notification_EventType {
  switch (object) {
    case 0:
    case "VIRTUAL_SCENE_CAMERA_INACTIVE":
      return Notification_EventType.VIRTUAL_SCENE_CAMERA_INACTIVE;
    case 1:
    case "VIRTUAL_SCENE_CAMERA_ACTIVE":
      return Notification_EventType.VIRTUAL_SCENE_CAMERA_ACTIVE;
    case 2:
    case "DISPLAY_CONFIGURATIONS_CHANGED_UI":
      return Notification_EventType.DISPLAY_CONFIGURATIONS_CHANGED_UI;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Notification_EventType.UNRECOGNIZED;
  }
}

export function notification_EventTypeToJSON(object: Notification_EventType): string {
  switch (object) {
    case Notification_EventType.VIRTUAL_SCENE_CAMERA_INACTIVE:
      return "VIRTUAL_SCENE_CAMERA_INACTIVE";
    case Notification_EventType.VIRTUAL_SCENE_CAMERA_ACTIVE:
      return "VIRTUAL_SCENE_CAMERA_ACTIVE";
    case Notification_EventType.DISPLAY_CONFIGURATIONS_CHANGED_UI:
      return "DISPLAY_CONFIGURATIONS_CHANGED_UI";
    case Notification_EventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface BootCompletedNotification {
  /**
   * The time in milliseconds it took for the boot to complete.
   * Note that this value can be 0 when you are loading from a snapshot.
   */
  time: number;
}

/**
 * Fired when the virtual scene camera is activated or deactivated and also in
 * response to the streamNotification call.
 */
export interface CameraNotification {
  /** Indicates whether the camera app was activated or deactivated. */
  active: boolean;
  /** The display the camera app is associated with. */
  display: number;
}

/**
 * Fired when an update to a display event has been fired through the extended
 * ui. This does not fire events when the display is changed through the console
 * or the gRPC endpoint.
 */
export interface DisplayConfigurationsChangedNotification {
  displayConfigurations: DisplayConfigurations | undefined;
}

/** Rotation angles are relative to the current orientation. */
export interface RotationRadian {
  /** Angle of rotation around the x axis in right-handed direction. */
  x: number;
  /** Angle of rotation around the y axis in right-handed direction. */
  y: number;
  /** Angle of rotation around the z axis in right-handed direction. */
  z: number;
}

/** Velocity is measured in meters per second. */
export interface Velocity {
  x: number;
  y: number;
  z: number;
}

/** Must follow the definition in "external/qemu/android/hw-sensors.h" */
export interface Posture {
  value: Posture_PostureValue;
}

export enum Posture_PostureValue {
  POSTURE_UNKNOWN = 0,
  POSTURE_CLOSED = 1,
  POSTURE_HALF_OPENED = 2,
  POSTURE_OPENED = 3,
  POSTURE_FLIPPED = 4,
  POSTURE_TENT = 5,
  POSTURE_MAX = 6,
  UNRECOGNIZED = -1,
}

export function posture_PostureValueFromJSON(object: any): Posture_PostureValue {
  switch (object) {
    case 0:
    case "POSTURE_UNKNOWN":
      return Posture_PostureValue.POSTURE_UNKNOWN;
    case 1:
    case "POSTURE_CLOSED":
      return Posture_PostureValue.POSTURE_CLOSED;
    case 2:
    case "POSTURE_HALF_OPENED":
      return Posture_PostureValue.POSTURE_HALF_OPENED;
    case 3:
    case "POSTURE_OPENED":
      return Posture_PostureValue.POSTURE_OPENED;
    case 4:
    case "POSTURE_FLIPPED":
      return Posture_PostureValue.POSTURE_FLIPPED;
    case 5:
    case "POSTURE_TENT":
      return Posture_PostureValue.POSTURE_TENT;
    case 6:
    case "POSTURE_MAX":
      return Posture_PostureValue.POSTURE_MAX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Posture_PostureValue.UNRECOGNIZED;
  }
}

export function posture_PostureValueToJSON(object: Posture_PostureValue): string {
  switch (object) {
    case Posture_PostureValue.POSTURE_UNKNOWN:
      return "POSTURE_UNKNOWN";
    case Posture_PostureValue.POSTURE_CLOSED:
      return "POSTURE_CLOSED";
    case Posture_PostureValue.POSTURE_HALF_OPENED:
      return "POSTURE_HALF_OPENED";
    case Posture_PostureValue.POSTURE_OPENED:
      return "POSTURE_OPENED";
    case Posture_PostureValue.POSTURE_FLIPPED:
      return "POSTURE_FLIPPED";
    case Posture_PostureValue.POSTURE_TENT:
      return "POSTURE_TENT";
    case Posture_PostureValue.POSTURE_MAX:
      return "POSTURE_MAX";
    case Posture_PostureValue.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PhoneNumber {
  /**
   * The phone number should be a valid GSM-formatted number as specified by
   * 3GPP 23.040 Sec 9.1.2.5.
   *
   * For example: +3106225412 or (650) 555-1221
   */
  number: string;
}

function createBaseVmRunState(): VmRunState {
  return { state: 0 };
}

export const VmRunState: MessageFns<VmRunState> = {
  encode(message: VmRunState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VmRunState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVmRunState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VmRunState {
    return { state: isSet(object.state) ? vmRunState_RunStateFromJSON(object.state) : 0 };
  },

  toJSON(message: VmRunState): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = vmRunState_RunStateToJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VmRunState>, I>>(base?: I): VmRunState {
    return VmRunState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VmRunState>, I>>(object: I): VmRunState {
    const message = createBaseVmRunState();
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseParameterValue(): ParameterValue {
  return { data: [] };
}

export const ParameterValue: MessageFns<ParameterValue> = {
  encode(message: ParameterValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.data) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 13) {
            message.data.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.data.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterValue {
    return { data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => globalThis.Number(e)) : [] };
  },

  toJSON(message: ParameterValue): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ParameterValue>, I>>(base?: I): ParameterValue {
    return ParameterValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ParameterValue>, I>>(object: I): ParameterValue {
    const message = createBaseParameterValue();
    message.data = object.data?.map((e) => e) || [];
    return message;
  },
};

function createBasePhysicalModelValue(): PhysicalModelValue {
  return { target: 0, status: 0, value: undefined };
}

export const PhysicalModelValue: MessageFns<PhysicalModelValue> = {
  encode(message: PhysicalModelValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== 0) {
      writer.uint32(8).int32(message.target);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.value !== undefined) {
      ParameterValue.encode(message.value, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhysicalModelValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhysicalModelValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = ParameterValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhysicalModelValue {
    return {
      target: isSet(object.target) ? physicalModelValue_PhysicalTypeFromJSON(object.target) : 0,
      status: isSet(object.status) ? physicalModelValue_StateFromJSON(object.status) : 0,
      value: isSet(object.value) ? ParameterValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: PhysicalModelValue): unknown {
    const obj: any = {};
    if (message.target !== 0) {
      obj.target = physicalModelValue_PhysicalTypeToJSON(message.target);
    }
    if (message.status !== 0) {
      obj.status = physicalModelValue_StateToJSON(message.status);
    }
    if (message.value !== undefined) {
      obj.value = ParameterValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PhysicalModelValue>, I>>(base?: I): PhysicalModelValue {
    return PhysicalModelValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PhysicalModelValue>, I>>(object: I): PhysicalModelValue {
    const message = createBasePhysicalModelValue();
    message.target = object.target ?? 0;
    message.status = object.status ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? ParameterValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSensorValue(): SensorValue {
  return { target: 0, status: 0, value: undefined };
}

export const SensorValue: MessageFns<SensorValue> = {
  encode(message: SensorValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== 0) {
      writer.uint32(8).int32(message.target);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.value !== undefined) {
      ParameterValue.encode(message.value, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SensorValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSensorValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = ParameterValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SensorValue {
    return {
      target: isSet(object.target) ? sensorValue_SensorTypeFromJSON(object.target) : 0,
      status: isSet(object.status) ? sensorValue_StateFromJSON(object.status) : 0,
      value: isSet(object.value) ? ParameterValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SensorValue): unknown {
    const obj: any = {};
    if (message.target !== 0) {
      obj.target = sensorValue_SensorTypeToJSON(message.target);
    }
    if (message.status !== 0) {
      obj.status = sensorValue_StateToJSON(message.status);
    }
    if (message.value !== undefined) {
      obj.value = ParameterValue.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SensorValue>, I>>(base?: I): SensorValue {
    return SensorValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SensorValue>, I>>(object: I): SensorValue {
    const message = createBaseSensorValue();
    message.target = object.target ?? 0;
    message.status = object.status ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? ParameterValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseBrightnessValue(): BrightnessValue {
  return { target: 0, value: 0 };
}

export const BrightnessValue: MessageFns<BrightnessValue> = {
  encode(message: BrightnessValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== 0) {
      writer.uint32(8).int32(message.target);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrightnessValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrightnessValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrightnessValue {
    return {
      target: isSet(object.target) ? brightnessValue_LightTypeFromJSON(object.target) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: BrightnessValue): unknown {
    const obj: any = {};
    if (message.target !== 0) {
      obj.target = brightnessValue_LightTypeToJSON(message.target);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BrightnessValue>, I>>(base?: I): BrightnessValue {
    return BrightnessValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BrightnessValue>, I>>(object: I): BrightnessValue {
    const message = createBaseBrightnessValue();
    message.target = object.target ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseDisplayMode(): DisplayMode {
  return { value: 0 };
}

export const DisplayMode: MessageFns<DisplayMode> = {
  encode(message: DisplayMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisplayMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisplayMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisplayMode {
    return { value: isSet(object.value) ? displayModeValueFromJSON(object.value) : 0 };
  },

  toJSON(message: DisplayMode): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = displayModeValueToJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DisplayMode>, I>>(base?: I): DisplayMode {
    return DisplayMode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisplayMode>, I>>(object: I): DisplayMode {
    const message = createBaseDisplayMode();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseLogMessage(): LogMessage {
  return { contents: "", start: 0, next: 0, sort: 0, entries: [] };
}

export const LogMessage: MessageFns<LogMessage> = {
  encode(message: LogMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contents !== "") {
      writer.uint32(10).string(message.contents);
    }
    if (message.start !== 0) {
      writer.uint32(16).int64(message.start);
    }
    if (message.next !== 0) {
      writer.uint32(24).int64(message.next);
    }
    if (message.sort !== 0) {
      writer.uint32(32).int32(message.sort);
    }
    for (const v of message.entries) {
      LogcatEntry.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contents = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.start = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.next = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sort = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.entries.push(LogcatEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogMessage {
    return {
      contents: isSet(object.contents) ? globalThis.String(object.contents) : "",
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      next: isSet(object.next) ? globalThis.Number(object.next) : 0,
      sort: isSet(object.sort) ? logMessage_LogTypeFromJSON(object.sort) : 0,
      entries: globalThis.Array.isArray(object?.entries) ? object.entries.map((e: any) => LogcatEntry.fromJSON(e)) : [],
    };
  },

  toJSON(message: LogMessage): unknown {
    const obj: any = {};
    if (message.contents !== "") {
      obj.contents = message.contents;
    }
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.next !== 0) {
      obj.next = Math.round(message.next);
    }
    if (message.sort !== 0) {
      obj.sort = logMessage_LogTypeToJSON(message.sort);
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => LogcatEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogMessage>, I>>(base?: I): LogMessage {
    return LogMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogMessage>, I>>(object: I): LogMessage {
    const message = createBaseLogMessage();
    message.contents = object.contents ?? "";
    message.start = object.start ?? 0;
    message.next = object.next ?? 0;
    message.sort = object.sort ?? 0;
    message.entries = object.entries?.map((e) => LogcatEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLogcatEntry(): LogcatEntry {
  return { timestamp: 0, pid: 0, tid: 0, level: 0, tag: "", msg: "" };
}

export const LogcatEntry: MessageFns<LogcatEntry> = {
  encode(message: LogcatEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== 0) {
      writer.uint32(8).uint64(message.timestamp);
    }
    if (message.pid !== 0) {
      writer.uint32(16).uint32(message.pid);
    }
    if (message.tid !== 0) {
      writer.uint32(24).uint32(message.tid);
    }
    if (message.level !== 0) {
      writer.uint32(32).int32(message.level);
    }
    if (message.tag !== "") {
      writer.uint32(42).string(message.tag);
    }
    if (message.msg !== "") {
      writer.uint32(50).string(message.msg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogcatEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogcatEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pid = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.tid = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.msg = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogcatEntry {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      pid: isSet(object.pid) ? globalThis.Number(object.pid) : 0,
      tid: isSet(object.tid) ? globalThis.Number(object.tid) : 0,
      level: isSet(object.level) ? logcatEntry_LogLevelFromJSON(object.level) : 0,
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
    };
  },

  toJSON(message: LogcatEntry): unknown {
    const obj: any = {};
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.pid !== 0) {
      obj.pid = Math.round(message.pid);
    }
    if (message.tid !== 0) {
      obj.tid = Math.round(message.tid);
    }
    if (message.level !== 0) {
      obj.level = logcatEntry_LogLevelToJSON(message.level);
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogcatEntry>, I>>(base?: I): LogcatEntry {
    return LogcatEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogcatEntry>, I>>(object: I): LogcatEntry {
    const message = createBaseLogcatEntry();
    message.timestamp = object.timestamp ?? 0;
    message.pid = object.pid ?? 0;
    message.tid = object.tid ?? 0;
    message.level = object.level ?? 0;
    message.tag = object.tag ?? "";
    message.msg = object.msg ?? "";
    return message;
  },
};

function createBaseVmConfiguration(): VmConfiguration {
  return { hypervisorType: 0, numberOfCpuCores: 0, ramSizeBytes: 0 };
}

export const VmConfiguration: MessageFns<VmConfiguration> = {
  encode(message: VmConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hypervisorType !== 0) {
      writer.uint32(8).int32(message.hypervisorType);
    }
    if (message.numberOfCpuCores !== 0) {
      writer.uint32(16).int32(message.numberOfCpuCores);
    }
    if (message.ramSizeBytes !== 0) {
      writer.uint32(24).int64(message.ramSizeBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VmConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVmConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hypervisorType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numberOfCpuCores = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.ramSizeBytes = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VmConfiguration {
    return {
      hypervisorType: isSet(object.hypervisorType)
        ? vmConfiguration_VmHypervisorTypeFromJSON(object.hypervisorType)
        : 0,
      numberOfCpuCores: isSet(object.numberOfCpuCores) ? globalThis.Number(object.numberOfCpuCores) : 0,
      ramSizeBytes: isSet(object.ramSizeBytes) ? globalThis.Number(object.ramSizeBytes) : 0,
    };
  },

  toJSON(message: VmConfiguration): unknown {
    const obj: any = {};
    if (message.hypervisorType !== 0) {
      obj.hypervisorType = vmConfiguration_VmHypervisorTypeToJSON(message.hypervisorType);
    }
    if (message.numberOfCpuCores !== 0) {
      obj.numberOfCpuCores = Math.round(message.numberOfCpuCores);
    }
    if (message.ramSizeBytes !== 0) {
      obj.ramSizeBytes = Math.round(message.ramSizeBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VmConfiguration>, I>>(base?: I): VmConfiguration {
    return VmConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VmConfiguration>, I>>(object: I): VmConfiguration {
    const message = createBaseVmConfiguration();
    message.hypervisorType = object.hypervisorType ?? 0;
    message.numberOfCpuCores = object.numberOfCpuCores ?? 0;
    message.ramSizeBytes = object.ramSizeBytes ?? 0;
    return message;
  },
};

function createBaseClipData(): ClipData {
  return { text: "" };
}

export const ClipData: MessageFns<ClipData> = {
  encode(message: ClipData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClipData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClipData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClipData {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: ClipData): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClipData>, I>>(base?: I): ClipData {
    return ClipData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClipData>, I>>(object: I): ClipData {
    const message = createBaseClipData();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseTouch(): Touch {
  return { x: 0, y: 0, identifier: 0, pressure: 0, touchMajor: 0, touchMinor: 0, expiration: 0, orientation: 0 };
}

export const Touch: MessageFns<Touch> = {
  encode(message: Touch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(8).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).int32(message.y);
    }
    if (message.identifier !== 0) {
      writer.uint32(24).int32(message.identifier);
    }
    if (message.pressure !== 0) {
      writer.uint32(32).int32(message.pressure);
    }
    if (message.touchMajor !== 0) {
      writer.uint32(40).int32(message.touchMajor);
    }
    if (message.touchMinor !== 0) {
      writer.uint32(48).int32(message.touchMinor);
    }
    if (message.expiration !== 0) {
      writer.uint32(56).int32(message.expiration);
    }
    if (message.orientation !== 0) {
      writer.uint32(64).int32(message.orientation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Touch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTouch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.x = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.y = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.identifier = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pressure = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.touchMajor = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.touchMinor = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.expiration = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.orientation = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Touch {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      identifier: isSet(object.identifier) ? globalThis.Number(object.identifier) : 0,
      pressure: isSet(object.pressure) ? globalThis.Number(object.pressure) : 0,
      touchMajor: isSet(object.touchMajor) ? globalThis.Number(object.touchMajor) : 0,
      touchMinor: isSet(object.touchMinor) ? globalThis.Number(object.touchMinor) : 0,
      expiration: isSet(object.expiration) ? touch_EventExpirationFromJSON(object.expiration) : 0,
      orientation: isSet(object.orientation) ? globalThis.Number(object.orientation) : 0,
    };
  },

  toJSON(message: Touch): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.identifier !== 0) {
      obj.identifier = Math.round(message.identifier);
    }
    if (message.pressure !== 0) {
      obj.pressure = Math.round(message.pressure);
    }
    if (message.touchMajor !== 0) {
      obj.touchMajor = Math.round(message.touchMajor);
    }
    if (message.touchMinor !== 0) {
      obj.touchMinor = Math.round(message.touchMinor);
    }
    if (message.expiration !== 0) {
      obj.expiration = touch_EventExpirationToJSON(message.expiration);
    }
    if (message.orientation !== 0) {
      obj.orientation = Math.round(message.orientation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Touch>, I>>(base?: I): Touch {
    return Touch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Touch>, I>>(object: I): Touch {
    const message = createBaseTouch();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.identifier = object.identifier ?? 0;
    message.pressure = object.pressure ?? 0;
    message.touchMajor = object.touchMajor ?? 0;
    message.touchMinor = object.touchMinor ?? 0;
    message.expiration = object.expiration ?? 0;
    message.orientation = object.orientation ?? 0;
    return message;
  },
};

function createBasePen(): Pen {
  return { location: undefined, buttonPressed: false, rubberPointer: false };
}

export const Pen: MessageFns<Pen> = {
  encode(message: Pen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== undefined) {
      Touch.encode(message.location, writer.uint32(10).fork()).join();
    }
    if (message.buttonPressed !== false) {
      writer.uint32(16).bool(message.buttonPressed);
    }
    if (message.rubberPointer !== false) {
      writer.uint32(24).bool(message.rubberPointer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.location = Touch.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.buttonPressed = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rubberPointer = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pen {
    return {
      location: isSet(object.location) ? Touch.fromJSON(object.location) : undefined,
      buttonPressed: isSet(object.buttonPressed) ? globalThis.Boolean(object.buttonPressed) : false,
      rubberPointer: isSet(object.rubberPointer) ? globalThis.Boolean(object.rubberPointer) : false,
    };
  },

  toJSON(message: Pen): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = Touch.toJSON(message.location);
    }
    if (message.buttonPressed !== false) {
      obj.buttonPressed = message.buttonPressed;
    }
    if (message.rubberPointer !== false) {
      obj.rubberPointer = message.rubberPointer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pen>, I>>(base?: I): Pen {
    return Pen.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pen>, I>>(object: I): Pen {
    const message = createBasePen();
    message.location = (object.location !== undefined && object.location !== null)
      ? Touch.fromPartial(object.location)
      : undefined;
    message.buttonPressed = object.buttonPressed ?? false;
    message.rubberPointer = object.rubberPointer ?? false;
    return message;
  },
};

function createBaseTouchEvent(): TouchEvent {
  return { touches: [], display: 0 };
}

export const TouchEvent: MessageFns<TouchEvent> = {
  encode(message: TouchEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.touches) {
      Touch.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.display !== 0) {
      writer.uint32(16).int32(message.display);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TouchEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTouchEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.touches.push(Touch.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.display = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TouchEvent {
    return {
      touches: globalThis.Array.isArray(object?.touches) ? object.touches.map((e: any) => Touch.fromJSON(e)) : [],
      display: isSet(object.display) ? globalThis.Number(object.display) : 0,
    };
  },

  toJSON(message: TouchEvent): unknown {
    const obj: any = {};
    if (message.touches?.length) {
      obj.touches = message.touches.map((e) => Touch.toJSON(e));
    }
    if (message.display !== 0) {
      obj.display = Math.round(message.display);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TouchEvent>, I>>(base?: I): TouchEvent {
    return TouchEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TouchEvent>, I>>(object: I): TouchEvent {
    const message = createBaseTouchEvent();
    message.touches = object.touches?.map((e) => Touch.fromPartial(e)) || [];
    message.display = object.display ?? 0;
    return message;
  },
};

function createBasePenEvent(): PenEvent {
  return { events: [], display: 0 };
}

export const PenEvent: MessageFns<PenEvent> = {
  encode(message: PenEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      Pen.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.display !== 0) {
      writer.uint32(16).int32(message.display);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PenEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePenEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(Pen.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.display = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PenEvent {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => Pen.fromJSON(e)) : [],
      display: isSet(object.display) ? globalThis.Number(object.display) : 0,
    };
  },

  toJSON(message: PenEvent): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => Pen.toJSON(e));
    }
    if (message.display !== 0) {
      obj.display = Math.round(message.display);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PenEvent>, I>>(base?: I): PenEvent {
    return PenEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PenEvent>, I>>(object: I): PenEvent {
    const message = createBasePenEvent();
    message.events = object.events?.map((e) => Pen.fromPartial(e)) || [];
    message.display = object.display ?? 0;
    return message;
  },
};

function createBaseMouseEvent(): MouseEvent {
  return { x: 0, y: 0, buttons: 0, display: 0 };
}

export const MouseEvent: MessageFns<MouseEvent> = {
  encode(message: MouseEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(8).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).int32(message.y);
    }
    if (message.buttons !== 0) {
      writer.uint32(24).int32(message.buttons);
    }
    if (message.display !== 0) {
      writer.uint32(32).int32(message.display);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MouseEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMouseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.x = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.y = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.buttons = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.display = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MouseEvent {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      buttons: isSet(object.buttons) ? globalThis.Number(object.buttons) : 0,
      display: isSet(object.display) ? globalThis.Number(object.display) : 0,
    };
  },

  toJSON(message: MouseEvent): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.buttons !== 0) {
      obj.buttons = Math.round(message.buttons);
    }
    if (message.display !== 0) {
      obj.display = Math.round(message.display);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MouseEvent>, I>>(base?: I): MouseEvent {
    return MouseEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MouseEvent>, I>>(object: I): MouseEvent {
    const message = createBaseMouseEvent();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.buttons = object.buttons ?? 0;
    message.display = object.display ?? 0;
    return message;
  },
};

function createBaseWheelEvent(): WheelEvent {
  return { dx: 0, dy: 0, display: 0 };
}

export const WheelEvent: MessageFns<WheelEvent> = {
  encode(message: WheelEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dx !== 0) {
      writer.uint32(8).int32(message.dx);
    }
    if (message.dy !== 0) {
      writer.uint32(16).int32(message.dy);
    }
    if (message.display !== 0) {
      writer.uint32(24).int32(message.display);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WheelEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWheelEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dx = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dy = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.display = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WheelEvent {
    return {
      dx: isSet(object.dx) ? globalThis.Number(object.dx) : 0,
      dy: isSet(object.dy) ? globalThis.Number(object.dy) : 0,
      display: isSet(object.display) ? globalThis.Number(object.display) : 0,
    };
  },

  toJSON(message: WheelEvent): unknown {
    const obj: any = {};
    if (message.dx !== 0) {
      obj.dx = Math.round(message.dx);
    }
    if (message.dy !== 0) {
      obj.dy = Math.round(message.dy);
    }
    if (message.display !== 0) {
      obj.display = Math.round(message.display);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WheelEvent>, I>>(base?: I): WheelEvent {
    return WheelEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WheelEvent>, I>>(object: I): WheelEvent {
    const message = createBaseWheelEvent();
    message.dx = object.dx ?? 0;
    message.dy = object.dy ?? 0;
    message.display = object.display ?? 0;
    return message;
  },
};

function createBaseKeyboardEvent(): KeyboardEvent {
  return { codeType: 0, eventType: 0, keyCode: 0, key: "", text: "" };
}

export const KeyboardEvent: MessageFns<KeyboardEvent> = {
  encode(message: KeyboardEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.codeType !== 0) {
      writer.uint32(8).int32(message.codeType);
    }
    if (message.eventType !== 0) {
      writer.uint32(16).int32(message.eventType);
    }
    if (message.keyCode !== 0) {
      writer.uint32(24).int32(message.keyCode);
    }
    if (message.key !== "") {
      writer.uint32(34).string(message.key);
    }
    if (message.text !== "") {
      writer.uint32(42).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyboardEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyboardEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.codeType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.keyCode = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyboardEvent {
    return {
      codeType: isSet(object.codeType) ? keyboardEvent_KeyCodeTypeFromJSON(object.codeType) : 0,
      eventType: isSet(object.eventType) ? keyboardEvent_KeyEventTypeFromJSON(object.eventType) : 0,
      keyCode: isSet(object.keyCode) ? globalThis.Number(object.keyCode) : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
    };
  },

  toJSON(message: KeyboardEvent): unknown {
    const obj: any = {};
    if (message.codeType !== 0) {
      obj.codeType = keyboardEvent_KeyCodeTypeToJSON(message.codeType);
    }
    if (message.eventType !== 0) {
      obj.eventType = keyboardEvent_KeyEventTypeToJSON(message.eventType);
    }
    if (message.keyCode !== 0) {
      obj.keyCode = Math.round(message.keyCode);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyboardEvent>, I>>(base?: I): KeyboardEvent {
    return KeyboardEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyboardEvent>, I>>(object: I): KeyboardEvent {
    const message = createBaseKeyboardEvent();
    message.codeType = object.codeType ?? 0;
    message.eventType = object.eventType ?? 0;
    message.keyCode = object.keyCode ?? 0;
    message.key = object.key ?? "";
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseInputEvent(): InputEvent {
  return {
    keyEvent: undefined,
    touchEvent: undefined,
    mouseEvent: undefined,
    androidEvent: undefined,
    penEvent: undefined,
    wheelEvent: undefined,
  };
}

export const InputEvent: MessageFns<InputEvent> = {
  encode(message: InputEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyEvent !== undefined) {
      KeyboardEvent.encode(message.keyEvent, writer.uint32(10).fork()).join();
    }
    if (message.touchEvent !== undefined) {
      TouchEvent.encode(message.touchEvent, writer.uint32(18).fork()).join();
    }
    if (message.mouseEvent !== undefined) {
      MouseEvent.encode(message.mouseEvent, writer.uint32(26).fork()).join();
    }
    if (message.androidEvent !== undefined) {
      AndroidEvent.encode(message.androidEvent, writer.uint32(34).fork()).join();
    }
    if (message.penEvent !== undefined) {
      PenEvent.encode(message.penEvent, writer.uint32(42).fork()).join();
    }
    if (message.wheelEvent !== undefined) {
      WheelEvent.encode(message.wheelEvent, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyEvent = KeyboardEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.touchEvent = TouchEvent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mouseEvent = MouseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.androidEvent = AndroidEvent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.penEvent = PenEvent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.wheelEvent = WheelEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputEvent {
    return {
      keyEvent: isSet(object.keyEvent) ? KeyboardEvent.fromJSON(object.keyEvent) : undefined,
      touchEvent: isSet(object.touchEvent) ? TouchEvent.fromJSON(object.touchEvent) : undefined,
      mouseEvent: isSet(object.mouseEvent) ? MouseEvent.fromJSON(object.mouseEvent) : undefined,
      androidEvent: isSet(object.androidEvent) ? AndroidEvent.fromJSON(object.androidEvent) : undefined,
      penEvent: isSet(object.penEvent) ? PenEvent.fromJSON(object.penEvent) : undefined,
      wheelEvent: isSet(object.wheelEvent) ? WheelEvent.fromJSON(object.wheelEvent) : undefined,
    };
  },

  toJSON(message: InputEvent): unknown {
    const obj: any = {};
    if (message.keyEvent !== undefined) {
      obj.keyEvent = KeyboardEvent.toJSON(message.keyEvent);
    }
    if (message.touchEvent !== undefined) {
      obj.touchEvent = TouchEvent.toJSON(message.touchEvent);
    }
    if (message.mouseEvent !== undefined) {
      obj.mouseEvent = MouseEvent.toJSON(message.mouseEvent);
    }
    if (message.androidEvent !== undefined) {
      obj.androidEvent = AndroidEvent.toJSON(message.androidEvent);
    }
    if (message.penEvent !== undefined) {
      obj.penEvent = PenEvent.toJSON(message.penEvent);
    }
    if (message.wheelEvent !== undefined) {
      obj.wheelEvent = WheelEvent.toJSON(message.wheelEvent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputEvent>, I>>(base?: I): InputEvent {
    return InputEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputEvent>, I>>(object: I): InputEvent {
    const message = createBaseInputEvent();
    message.keyEvent = (object.keyEvent !== undefined && object.keyEvent !== null)
      ? KeyboardEvent.fromPartial(object.keyEvent)
      : undefined;
    message.touchEvent = (object.touchEvent !== undefined && object.touchEvent !== null)
      ? TouchEvent.fromPartial(object.touchEvent)
      : undefined;
    message.mouseEvent = (object.mouseEvent !== undefined && object.mouseEvent !== null)
      ? MouseEvent.fromPartial(object.mouseEvent)
      : undefined;
    message.androidEvent = (object.androidEvent !== undefined && object.androidEvent !== null)
      ? AndroidEvent.fromPartial(object.androidEvent)
      : undefined;
    message.penEvent = (object.penEvent !== undefined && object.penEvent !== null)
      ? PenEvent.fromPartial(object.penEvent)
      : undefined;
    message.wheelEvent = (object.wheelEvent !== undefined && object.wheelEvent !== null)
      ? WheelEvent.fromPartial(object.wheelEvent)
      : undefined;
    return message;
  },
};

function createBaseAndroidEvent(): AndroidEvent {
  return { type: 0, code: 0, value: 0, display: 0 };
}

export const AndroidEvent: MessageFns<AndroidEvent> = {
  encode(message: AndroidEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.code !== 0) {
      writer.uint32(16).int32(message.code);
    }
    if (message.value !== 0) {
      writer.uint32(24).int32(message.value);
    }
    if (message.display !== 0) {
      writer.uint32(32).int32(message.display);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AndroidEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAndroidEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.display = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AndroidEvent {
    return {
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      display: isSet(object.display) ? globalThis.Number(object.display) : 0,
    };
  },

  toJSON(message: AndroidEvent): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.display !== 0) {
      obj.display = Math.round(message.display);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AndroidEvent>, I>>(base?: I): AndroidEvent {
    return AndroidEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AndroidEvent>, I>>(object: I): AndroidEvent {
    const message = createBaseAndroidEvent();
    message.type = object.type ?? 0;
    message.code = object.code ?? 0;
    message.value = object.value ?? 0;
    message.display = object.display ?? 0;
    return message;
  },
};

function createBaseFingerprint(): Fingerprint {
  return { isTouching: false, touchId: 0 };
}

export const Fingerprint: MessageFns<Fingerprint> = {
  encode(message: Fingerprint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isTouching !== false) {
      writer.uint32(8).bool(message.isTouching);
    }
    if (message.touchId !== 0) {
      writer.uint32(16).int32(message.touchId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fingerprint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFingerprint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isTouching = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.touchId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fingerprint {
    return {
      isTouching: isSet(object.isTouching) ? globalThis.Boolean(object.isTouching) : false,
      touchId: isSet(object.touchId) ? globalThis.Number(object.touchId) : 0,
    };
  },

  toJSON(message: Fingerprint): unknown {
    const obj: any = {};
    if (message.isTouching !== false) {
      obj.isTouching = message.isTouching;
    }
    if (message.touchId !== 0) {
      obj.touchId = Math.round(message.touchId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fingerprint>, I>>(base?: I): Fingerprint {
    return Fingerprint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fingerprint>, I>>(object: I): Fingerprint {
    const message = createBaseFingerprint();
    message.isTouching = object.isTouching ?? false;
    message.touchId = object.touchId ?? 0;
    return message;
  },
};

function createBaseGpsState(): GpsState {
  return { passiveUpdate: false, latitude: 0, longitude: 0, speed: 0, bearing: 0, altitude: 0, satellites: 0 };
}

export const GpsState: MessageFns<GpsState> = {
  encode(message: GpsState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.passiveUpdate !== false) {
      writer.uint32(8).bool(message.passiveUpdate);
    }
    if (message.latitude !== 0) {
      writer.uint32(17).double(message.latitude);
    }
    if (message.longitude !== 0) {
      writer.uint32(25).double(message.longitude);
    }
    if (message.speed !== 0) {
      writer.uint32(33).double(message.speed);
    }
    if (message.bearing !== 0) {
      writer.uint32(41).double(message.bearing);
    }
    if (message.altitude !== 0) {
      writer.uint32(49).double(message.altitude);
    }
    if (message.satellites !== 0) {
      writer.uint32(56).int32(message.satellites);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GpsState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGpsState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.passiveUpdate = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.latitude = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.longitude = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.speed = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.bearing = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.altitude = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.satellites = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GpsState {
    return {
      passiveUpdate: isSet(object.passiveUpdate) ? globalThis.Boolean(object.passiveUpdate) : false,
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
      speed: isSet(object.speed) ? globalThis.Number(object.speed) : 0,
      bearing: isSet(object.bearing) ? globalThis.Number(object.bearing) : 0,
      altitude: isSet(object.altitude) ? globalThis.Number(object.altitude) : 0,
      satellites: isSet(object.satellites) ? globalThis.Number(object.satellites) : 0,
    };
  },

  toJSON(message: GpsState): unknown {
    const obj: any = {};
    if (message.passiveUpdate !== false) {
      obj.passiveUpdate = message.passiveUpdate;
    }
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    if (message.speed !== 0) {
      obj.speed = message.speed;
    }
    if (message.bearing !== 0) {
      obj.bearing = message.bearing;
    }
    if (message.altitude !== 0) {
      obj.altitude = message.altitude;
    }
    if (message.satellites !== 0) {
      obj.satellites = Math.round(message.satellites);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GpsState>, I>>(base?: I): GpsState {
    return GpsState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GpsState>, I>>(object: I): GpsState {
    const message = createBaseGpsState();
    message.passiveUpdate = object.passiveUpdate ?? false;
    message.latitude = object.latitude ?? 0;
    message.longitude = object.longitude ?? 0;
    message.speed = object.speed ?? 0;
    message.bearing = object.bearing ?? 0;
    message.altitude = object.altitude ?? 0;
    message.satellites = object.satellites ?? 0;
    return message;
  },
};

function createBaseBatteryState(): BatteryState {
  return { hasBattery: false, isPresent: false, charger: 0, chargeLevel: 0, health: 0, status: 0 };
}

export const BatteryState: MessageFns<BatteryState> = {
  encode(message: BatteryState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasBattery !== false) {
      writer.uint32(8).bool(message.hasBattery);
    }
    if (message.isPresent !== false) {
      writer.uint32(16).bool(message.isPresent);
    }
    if (message.charger !== 0) {
      writer.uint32(24).int32(message.charger);
    }
    if (message.chargeLevel !== 0) {
      writer.uint32(32).int32(message.chargeLevel);
    }
    if (message.health !== 0) {
      writer.uint32(40).int32(message.health);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatteryState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatteryState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasBattery = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isPresent = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.charger = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.chargeLevel = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.health = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatteryState {
    return {
      hasBattery: isSet(object.hasBattery) ? globalThis.Boolean(object.hasBattery) : false,
      isPresent: isSet(object.isPresent) ? globalThis.Boolean(object.isPresent) : false,
      charger: isSet(object.charger) ? batteryState_BatteryChargerFromJSON(object.charger) : 0,
      chargeLevel: isSet(object.chargeLevel) ? globalThis.Number(object.chargeLevel) : 0,
      health: isSet(object.health) ? batteryState_BatteryHealthFromJSON(object.health) : 0,
      status: isSet(object.status) ? batteryState_BatteryStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: BatteryState): unknown {
    const obj: any = {};
    if (message.hasBattery !== false) {
      obj.hasBattery = message.hasBattery;
    }
    if (message.isPresent !== false) {
      obj.isPresent = message.isPresent;
    }
    if (message.charger !== 0) {
      obj.charger = batteryState_BatteryChargerToJSON(message.charger);
    }
    if (message.chargeLevel !== 0) {
      obj.chargeLevel = Math.round(message.chargeLevel);
    }
    if (message.health !== 0) {
      obj.health = batteryState_BatteryHealthToJSON(message.health);
    }
    if (message.status !== 0) {
      obj.status = batteryState_BatteryStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatteryState>, I>>(base?: I): BatteryState {
    return BatteryState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatteryState>, I>>(object: I): BatteryState {
    const message = createBaseBatteryState();
    message.hasBattery = object.hasBattery ?? false;
    message.isPresent = object.isPresent ?? false;
    message.charger = object.charger ?? 0;
    message.chargeLevel = object.chargeLevel ?? 0;
    message.health = object.health ?? 0;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseImageTransport(): ImageTransport {
  return { channel: 0, handle: "" };
}

export const ImageTransport: MessageFns<ImageTransport> = {
  encode(message: ImageTransport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== 0) {
      writer.uint32(8).int32(message.channel);
    }
    if (message.handle !== "") {
      writer.uint32(18).string(message.handle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageTransport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageTransport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.handle = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageTransport {
    return {
      channel: isSet(object.channel) ? imageTransport_TransportChannelFromJSON(object.channel) : 0,
      handle: isSet(object.handle) ? globalThis.String(object.handle) : "",
    };
  },

  toJSON(message: ImageTransport): unknown {
    const obj: any = {};
    if (message.channel !== 0) {
      obj.channel = imageTransport_TransportChannelToJSON(message.channel);
    }
    if (message.handle !== "") {
      obj.handle = message.handle;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageTransport>, I>>(base?: I): ImageTransport {
    return ImageTransport.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageTransport>, I>>(object: I): ImageTransport {
    const message = createBaseImageTransport();
    message.channel = object.channel ?? 0;
    message.handle = object.handle ?? "";
    return message;
  },
};

function createBaseFoldedDisplay(): FoldedDisplay {
  return { width: 0, height: 0, xOffset: 0, yOffset: 0 };
}

export const FoldedDisplay: MessageFns<FoldedDisplay> = {
  encode(message: FoldedDisplay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.width !== 0) {
      writer.uint32(8).uint32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(16).uint32(message.height);
    }
    if (message.xOffset !== 0) {
      writer.uint32(24).uint32(message.xOffset);
    }
    if (message.yOffset !== 0) {
      writer.uint32(32).uint32(message.yOffset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FoldedDisplay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFoldedDisplay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.width = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.xOffset = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.yOffset = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FoldedDisplay {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      xOffset: isSet(object.xOffset) ? globalThis.Number(object.xOffset) : 0,
      yOffset: isSet(object.yOffset) ? globalThis.Number(object.yOffset) : 0,
    };
  },

  toJSON(message: FoldedDisplay): unknown {
    const obj: any = {};
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.xOffset !== 0) {
      obj.xOffset = Math.round(message.xOffset);
    }
    if (message.yOffset !== 0) {
      obj.yOffset = Math.round(message.yOffset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FoldedDisplay>, I>>(base?: I): FoldedDisplay {
    return FoldedDisplay.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FoldedDisplay>, I>>(object: I): FoldedDisplay {
    const message = createBaseFoldedDisplay();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.xOffset = object.xOffset ?? 0;
    message.yOffset = object.yOffset ?? 0;
    return message;
  },
};

function createBaseImageFormat(): ImageFormat {
  return {
    format: 0,
    rotation: undefined,
    width: 0,
    height: 0,
    display: 0,
    transport: undefined,
    foldedDisplay: undefined,
    displayMode: 0,
  };
}

export const ImageFormat: MessageFns<ImageFormat> = {
  encode(message: ImageFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== 0) {
      writer.uint32(8).int32(message.format);
    }
    if (message.rotation !== undefined) {
      Rotation.encode(message.rotation, writer.uint32(18).fork()).join();
    }
    if (message.width !== 0) {
      writer.uint32(24).uint32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(32).uint32(message.height);
    }
    if (message.display !== 0) {
      writer.uint32(40).uint32(message.display);
    }
    if (message.transport !== undefined) {
      ImageTransport.encode(message.transport, writer.uint32(50).fork()).join();
    }
    if (message.foldedDisplay !== undefined) {
      FoldedDisplay.encode(message.foldedDisplay, writer.uint32(58).fork()).join();
    }
    if (message.displayMode !== 0) {
      writer.uint32(64).int32(message.displayMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rotation = Rotation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.width = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.display = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.transport = ImageTransport.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.foldedDisplay = FoldedDisplay.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.displayMode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageFormat {
    return {
      format: isSet(object.format) ? imageFormat_ImgFormatFromJSON(object.format) : 0,
      rotation: isSet(object.rotation) ? Rotation.fromJSON(object.rotation) : undefined,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      display: isSet(object.display) ? globalThis.Number(object.display) : 0,
      transport: isSet(object.transport) ? ImageTransport.fromJSON(object.transport) : undefined,
      foldedDisplay: isSet(object.foldedDisplay) ? FoldedDisplay.fromJSON(object.foldedDisplay) : undefined,
      displayMode: isSet(object.displayMode) ? displayModeValueFromJSON(object.displayMode) : 0,
    };
  },

  toJSON(message: ImageFormat): unknown {
    const obj: any = {};
    if (message.format !== 0) {
      obj.format = imageFormat_ImgFormatToJSON(message.format);
    }
    if (message.rotation !== undefined) {
      obj.rotation = Rotation.toJSON(message.rotation);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.display !== 0) {
      obj.display = Math.round(message.display);
    }
    if (message.transport !== undefined) {
      obj.transport = ImageTransport.toJSON(message.transport);
    }
    if (message.foldedDisplay !== undefined) {
      obj.foldedDisplay = FoldedDisplay.toJSON(message.foldedDisplay);
    }
    if (message.displayMode !== 0) {
      obj.displayMode = displayModeValueToJSON(message.displayMode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageFormat>, I>>(base?: I): ImageFormat {
    return ImageFormat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageFormat>, I>>(object: I): ImageFormat {
    const message = createBaseImageFormat();
    message.format = object.format ?? 0;
    message.rotation = (object.rotation !== undefined && object.rotation !== null)
      ? Rotation.fromPartial(object.rotation)
      : undefined;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.display = object.display ?? 0;
    message.transport = (object.transport !== undefined && object.transport !== null)
      ? ImageTransport.fromPartial(object.transport)
      : undefined;
    message.foldedDisplay = (object.foldedDisplay !== undefined && object.foldedDisplay !== null)
      ? FoldedDisplay.fromPartial(object.foldedDisplay)
      : undefined;
    message.displayMode = object.displayMode ?? 0;
    return message;
  },
};

function createBaseImage(): Image {
  return { format: undefined, width: 0, height: 0, image: new Uint8Array(0), seq: 0, timestampUs: 0 };
}

export const Image: MessageFns<Image> = {
  encode(message: Image, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== undefined) {
      ImageFormat.encode(message.format, writer.uint32(10).fork()).join();
    }
    if (message.width !== 0) {
      writer.uint32(16).uint32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(24).uint32(message.height);
    }
    if (message.image.length !== 0) {
      writer.uint32(34).bytes(message.image);
    }
    if (message.seq !== 0) {
      writer.uint32(40).uint32(message.seq);
    }
    if (message.timestampUs !== 0) {
      writer.uint32(48).uint64(message.timestampUs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Image {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.format = ImageFormat.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.width = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.image = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.seq = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.timestampUs = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Image {
    return {
      format: isSet(object.format) ? ImageFormat.fromJSON(object.format) : undefined,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      image: isSet(object.image) ? bytesFromBase64(object.image) : new Uint8Array(0),
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
      timestampUs: isSet(object.timestampUs) ? globalThis.Number(object.timestampUs) : 0,
    };
  },

  toJSON(message: Image): unknown {
    const obj: any = {};
    if (message.format !== undefined) {
      obj.format = ImageFormat.toJSON(message.format);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.image.length !== 0) {
      obj.image = base64FromBytes(message.image);
    }
    if (message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    if (message.timestampUs !== 0) {
      obj.timestampUs = Math.round(message.timestampUs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Image>, I>>(base?: I): Image {
    return Image.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Image>, I>>(object: I): Image {
    const message = createBaseImage();
    message.format = (object.format !== undefined && object.format !== null)
      ? ImageFormat.fromPartial(object.format)
      : undefined;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.image = object.image ?? new Uint8Array(0);
    message.seq = object.seq ?? 0;
    message.timestampUs = object.timestampUs ?? 0;
    return message;
  },
};

function createBaseRotation(): Rotation {
  return { rotation: 0, xAxis: 0, yAxis: 0, zAxis: 0 };
}

export const Rotation: MessageFns<Rotation> = {
  encode(message: Rotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rotation !== 0) {
      writer.uint32(8).int32(message.rotation);
    }
    if (message.xAxis !== 0) {
      writer.uint32(17).double(message.xAxis);
    }
    if (message.yAxis !== 0) {
      writer.uint32(25).double(message.yAxis);
    }
    if (message.zAxis !== 0) {
      writer.uint32(33).double(message.zAxis);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rotation = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.xAxis = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.yAxis = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.zAxis = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rotation {
    return {
      rotation: isSet(object.rotation) ? rotation_SkinRotationFromJSON(object.rotation) : 0,
      xAxis: isSet(object.xAxis) ? globalThis.Number(object.xAxis) : 0,
      yAxis: isSet(object.yAxis) ? globalThis.Number(object.yAxis) : 0,
      zAxis: isSet(object.zAxis) ? globalThis.Number(object.zAxis) : 0,
    };
  },

  toJSON(message: Rotation): unknown {
    const obj: any = {};
    if (message.rotation !== 0) {
      obj.rotation = rotation_SkinRotationToJSON(message.rotation);
    }
    if (message.xAxis !== 0) {
      obj.xAxis = message.xAxis;
    }
    if (message.yAxis !== 0) {
      obj.yAxis = message.yAxis;
    }
    if (message.zAxis !== 0) {
      obj.zAxis = message.zAxis;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Rotation>, I>>(base?: I): Rotation {
    return Rotation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Rotation>, I>>(object: I): Rotation {
    const message = createBaseRotation();
    message.rotation = object.rotation ?? 0;
    message.xAxis = object.xAxis ?? 0;
    message.yAxis = object.yAxis ?? 0;
    message.zAxis = object.zAxis ?? 0;
    return message;
  },
};

function createBasePhoneCall(): PhoneCall {
  return { operation: 0, number: "" };
}

export const PhoneCall: MessageFns<PhoneCall> = {
  encode(message: PhoneCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== 0) {
      writer.uint32(8).int32(message.operation);
    }
    if (message.number !== "") {
      writer.uint32(18).string(message.number);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhoneCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhoneCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.number = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhoneCall {
    return {
      operation: isSet(object.operation) ? phoneCall_OperationFromJSON(object.operation) : 0,
      number: isSet(object.number) ? globalThis.String(object.number) : "",
    };
  },

  toJSON(message: PhoneCall): unknown {
    const obj: any = {};
    if (message.operation !== 0) {
      obj.operation = phoneCall_OperationToJSON(message.operation);
    }
    if (message.number !== "") {
      obj.number = message.number;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PhoneCall>, I>>(base?: I): PhoneCall {
    return PhoneCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PhoneCall>, I>>(object: I): PhoneCall {
    const message = createBasePhoneCall();
    message.operation = object.operation ?? 0;
    message.number = object.number ?? "";
    return message;
  },
};

function createBasePhoneResponse(): PhoneResponse {
  return { response: 0 };
}

export const PhoneResponse: MessageFns<PhoneResponse> = {
  encode(message: PhoneResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== 0) {
      writer.uint32(8).int32(message.response);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhoneResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhoneResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhoneResponse {
    return { response: isSet(object.response) ? phoneResponse_ResponseFromJSON(object.response) : 0 };
  },

  toJSON(message: PhoneResponse): unknown {
    const obj: any = {};
    if (message.response !== 0) {
      obj.response = phoneResponse_ResponseToJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PhoneResponse>, I>>(base?: I): PhoneResponse {
    return PhoneResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PhoneResponse>, I>>(object: I): PhoneResponse {
    const message = createBasePhoneResponse();
    message.response = object.response ?? 0;
    return message;
  },
};

function createBaseEntry(): Entry {
  return { key: "", value: "" };
}

export const Entry: MessageFns<Entry> = {
  encode(message: Entry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Entry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Entry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Entry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Entry>, I>>(base?: I): Entry {
    return Entry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Entry>, I>>(object: I): Entry {
    const message = createBaseEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEntryList(): EntryList {
  return { entry: [] };
}

export const EntryList: MessageFns<EntryList> = {
  encode(message: EntryList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entry) {
      Entry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntryList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntryList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entry.push(Entry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntryList {
    return { entry: globalThis.Array.isArray(object?.entry) ? object.entry.map((e: any) => Entry.fromJSON(e)) : [] };
  },

  toJSON(message: EntryList): unknown {
    const obj: any = {};
    if (message.entry?.length) {
      obj.entry = message.entry.map((e) => Entry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EntryList>, I>>(base?: I): EntryList {
    return EntryList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EntryList>, I>>(object: I): EntryList {
    const message = createBaseEntryList();
    message.entry = object.entry?.map((e) => Entry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEmulatorStatus(): EmulatorStatus {
  return {
    version: "",
    uptime: 0,
    booted: false,
    vmConfig: undefined,
    hardwareConfig: undefined,
    heartbeat: 0,
    guestConfig: {},
  };
}

export const EmulatorStatus: MessageFns<EmulatorStatus> = {
  encode(message: EmulatorStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.uptime !== 0) {
      writer.uint32(16).uint64(message.uptime);
    }
    if (message.booted !== false) {
      writer.uint32(24).bool(message.booted);
    }
    if (message.vmConfig !== undefined) {
      VmConfiguration.encode(message.vmConfig, writer.uint32(34).fork()).join();
    }
    if (message.hardwareConfig !== undefined) {
      EntryList.encode(message.hardwareConfig, writer.uint32(42).fork()).join();
    }
    if (message.heartbeat !== 0) {
      writer.uint32(48).uint64(message.heartbeat);
    }
    Object.entries(message.guestConfig).forEach(([key, value]) => {
      EmulatorStatus_GuestConfigEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmulatorStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmulatorStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uptime = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.booted = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.vmConfig = VmConfiguration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.hardwareConfig = EntryList.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.heartbeat = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = EmulatorStatus_GuestConfigEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.guestConfig[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmulatorStatus {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      uptime: isSet(object.uptime) ? globalThis.Number(object.uptime) : 0,
      booted: isSet(object.booted) ? globalThis.Boolean(object.booted) : false,
      vmConfig: isSet(object.vmConfig) ? VmConfiguration.fromJSON(object.vmConfig) : undefined,
      hardwareConfig: isSet(object.hardwareConfig) ? EntryList.fromJSON(object.hardwareConfig) : undefined,
      heartbeat: isSet(object.heartbeat) ? globalThis.Number(object.heartbeat) : 0,
      guestConfig: isObject(object.guestConfig)
        ? Object.entries(object.guestConfig).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: EmulatorStatus): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.uptime !== 0) {
      obj.uptime = Math.round(message.uptime);
    }
    if (message.booted !== false) {
      obj.booted = message.booted;
    }
    if (message.vmConfig !== undefined) {
      obj.vmConfig = VmConfiguration.toJSON(message.vmConfig);
    }
    if (message.hardwareConfig !== undefined) {
      obj.hardwareConfig = EntryList.toJSON(message.hardwareConfig);
    }
    if (message.heartbeat !== 0) {
      obj.heartbeat = Math.round(message.heartbeat);
    }
    if (message.guestConfig) {
      const entries = Object.entries(message.guestConfig);
      if (entries.length > 0) {
        obj.guestConfig = {};
        entries.forEach(([k, v]) => {
          obj.guestConfig[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmulatorStatus>, I>>(base?: I): EmulatorStatus {
    return EmulatorStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmulatorStatus>, I>>(object: I): EmulatorStatus {
    const message = createBaseEmulatorStatus();
    message.version = object.version ?? "";
    message.uptime = object.uptime ?? 0;
    message.booted = object.booted ?? false;
    message.vmConfig = (object.vmConfig !== undefined && object.vmConfig !== null)
      ? VmConfiguration.fromPartial(object.vmConfig)
      : undefined;
    message.hardwareConfig = (object.hardwareConfig !== undefined && object.hardwareConfig !== null)
      ? EntryList.fromPartial(object.hardwareConfig)
      : undefined;
    message.heartbeat = object.heartbeat ?? 0;
    message.guestConfig = Object.entries(object.guestConfig ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseEmulatorStatus_GuestConfigEntry(): EmulatorStatus_GuestConfigEntry {
  return { key: "", value: "" };
}

export const EmulatorStatus_GuestConfigEntry: MessageFns<EmulatorStatus_GuestConfigEntry> = {
  encode(message: EmulatorStatus_GuestConfigEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmulatorStatus_GuestConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmulatorStatus_GuestConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmulatorStatus_GuestConfigEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EmulatorStatus_GuestConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmulatorStatus_GuestConfigEntry>, I>>(base?: I): EmulatorStatus_GuestConfigEntry {
    return EmulatorStatus_GuestConfigEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmulatorStatus_GuestConfigEntry>, I>>(
    object: I,
  ): EmulatorStatus_GuestConfigEntry {
    const message = createBaseEmulatorStatus_GuestConfigEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAudioFormat(): AudioFormat {
  return { samplingRate: 0, channels: 0, format: 0, mode: 0 };
}

export const AudioFormat: MessageFns<AudioFormat> = {
  encode(message: AudioFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.samplingRate !== 0) {
      writer.uint32(8).uint64(message.samplingRate);
    }
    if (message.channels !== 0) {
      writer.uint32(16).int32(message.channels);
    }
    if (message.format !== 0) {
      writer.uint32(24).int32(message.format);
    }
    if (message.mode !== 0) {
      writer.uint32(32).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.samplingRate = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channels = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioFormat {
    return {
      samplingRate: isSet(object.samplingRate) ? globalThis.Number(object.samplingRate) : 0,
      channels: isSet(object.channels) ? audioFormat_ChannelsFromJSON(object.channels) : 0,
      format: isSet(object.format) ? audioFormat_SampleFormatFromJSON(object.format) : 0,
      mode: isSet(object.mode) ? audioFormat_DeliveryModeFromJSON(object.mode) : 0,
    };
  },

  toJSON(message: AudioFormat): unknown {
    const obj: any = {};
    if (message.samplingRate !== 0) {
      obj.samplingRate = Math.round(message.samplingRate);
    }
    if (message.channels !== 0) {
      obj.channels = audioFormat_ChannelsToJSON(message.channels);
    }
    if (message.format !== 0) {
      obj.format = audioFormat_SampleFormatToJSON(message.format);
    }
    if (message.mode !== 0) {
      obj.mode = audioFormat_DeliveryModeToJSON(message.mode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AudioFormat>, I>>(base?: I): AudioFormat {
    return AudioFormat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioFormat>, I>>(object: I): AudioFormat {
    const message = createBaseAudioFormat();
    message.samplingRate = object.samplingRate ?? 0;
    message.channels = object.channels ?? 0;
    message.format = object.format ?? 0;
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseAudioPacket(): AudioPacket {
  return { format: undefined, timestamp: 0, audio: new Uint8Array(0) };
}

export const AudioPacket: MessageFns<AudioPacket> = {
  encode(message: AudioPacket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== undefined) {
      AudioFormat.encode(message.format, writer.uint32(10).fork()).join();
    }
    if (message.timestamp !== 0) {
      writer.uint32(16).uint64(message.timestamp);
    }
    if (message.audio.length !== 0) {
      writer.uint32(26).bytes(message.audio);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioPacket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioPacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.format = AudioFormat.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.audio = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioPacket {
    return {
      format: isSet(object.format) ? AudioFormat.fromJSON(object.format) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      audio: isSet(object.audio) ? bytesFromBase64(object.audio) : new Uint8Array(0),
    };
  },

  toJSON(message: AudioPacket): unknown {
    const obj: any = {};
    if (message.format !== undefined) {
      obj.format = AudioFormat.toJSON(message.format);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.audio.length !== 0) {
      obj.audio = base64FromBytes(message.audio);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AudioPacket>, I>>(base?: I): AudioPacket {
    return AudioPacket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AudioPacket>, I>>(object: I): AudioPacket {
    const message = createBaseAudioPacket();
    message.format = (object.format !== undefined && object.format !== null)
      ? AudioFormat.fromPartial(object.format)
      : undefined;
    message.timestamp = object.timestamp ?? 0;
    message.audio = object.audio ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSmsMessage(): SmsMessage {
  return { srcAddress: "", text: "" };
}

export const SmsMessage: MessageFns<SmsMessage> = {
  encode(message: SmsMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.srcAddress !== "") {
      writer.uint32(10).string(message.srcAddress);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SmsMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmsMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.srcAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SmsMessage {
    return {
      srcAddress: isSet(object.srcAddress) ? globalThis.String(object.srcAddress) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
    };
  },

  toJSON(message: SmsMessage): unknown {
    const obj: any = {};
    if (message.srcAddress !== "") {
      obj.srcAddress = message.srcAddress;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SmsMessage>, I>>(base?: I): SmsMessage {
    return SmsMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SmsMessage>, I>>(object: I): SmsMessage {
    const message = createBaseSmsMessage();
    message.srcAddress = object.srcAddress ?? "";
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseDisplayConfiguration(): DisplayConfiguration {
  return { width: 0, height: 0, dpi: 0, flags: 0, display: 0 };
}

export const DisplayConfiguration: MessageFns<DisplayConfiguration> = {
  encode(message: DisplayConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.width !== 0) {
      writer.uint32(8).uint32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(16).uint32(message.height);
    }
    if (message.dpi !== 0) {
      writer.uint32(24).uint32(message.dpi);
    }
    if (message.flags !== 0) {
      writer.uint32(32).uint32(message.flags);
    }
    if (message.display !== 0) {
      writer.uint32(40).uint32(message.display);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisplayConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisplayConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.width = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.dpi = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.display = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisplayConfiguration {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      dpi: isSet(object.dpi) ? globalThis.Number(object.dpi) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      display: isSet(object.display) ? globalThis.Number(object.display) : 0,
    };
  },

  toJSON(message: DisplayConfiguration): unknown {
    const obj: any = {};
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.dpi !== 0) {
      obj.dpi = Math.round(message.dpi);
    }
    if (message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.display !== 0) {
      obj.display = Math.round(message.display);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DisplayConfiguration>, I>>(base?: I): DisplayConfiguration {
    return DisplayConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisplayConfiguration>, I>>(object: I): DisplayConfiguration {
    const message = createBaseDisplayConfiguration();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.dpi = object.dpi ?? 0;
    message.flags = object.flags ?? 0;
    message.display = object.display ?? 0;
    return message;
  },
};

function createBaseDisplayConfigurations(): DisplayConfigurations {
  return { displays: [], userConfigurable: 0, maxDisplays: 0 };
}

export const DisplayConfigurations: MessageFns<DisplayConfigurations> = {
  encode(message: DisplayConfigurations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.displays) {
      DisplayConfiguration.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.userConfigurable !== 0) {
      writer.uint32(16).uint32(message.userConfigurable);
    }
    if (message.maxDisplays !== 0) {
      writer.uint32(24).uint32(message.maxDisplays);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisplayConfigurations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisplayConfigurations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displays.push(DisplayConfiguration.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userConfigurable = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxDisplays = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisplayConfigurations {
    return {
      displays: globalThis.Array.isArray(object?.displays)
        ? object.displays.map((e: any) => DisplayConfiguration.fromJSON(e))
        : [],
      userConfigurable: isSet(object.userConfigurable) ? globalThis.Number(object.userConfigurable) : 0,
      maxDisplays: isSet(object.maxDisplays) ? globalThis.Number(object.maxDisplays) : 0,
    };
  },

  toJSON(message: DisplayConfigurations): unknown {
    const obj: any = {};
    if (message.displays?.length) {
      obj.displays = message.displays.map((e) => DisplayConfiguration.toJSON(e));
    }
    if (message.userConfigurable !== 0) {
      obj.userConfigurable = Math.round(message.userConfigurable);
    }
    if (message.maxDisplays !== 0) {
      obj.maxDisplays = Math.round(message.maxDisplays);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DisplayConfigurations>, I>>(base?: I): DisplayConfigurations {
    return DisplayConfigurations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisplayConfigurations>, I>>(object: I): DisplayConfigurations {
    const message = createBaseDisplayConfigurations();
    message.displays = object.displays?.map((e) => DisplayConfiguration.fromPartial(e)) || [];
    message.userConfigurable = object.userConfigurable ?? 0;
    message.maxDisplays = object.maxDisplays ?? 0;
    return message;
  },
};

function createBaseNotification(): Notification {
  return {
    event: 0,
    cameraNotification: undefined,
    displayConfigurationsChangedNotification: undefined,
    posture: undefined,
    booted: undefined,
    brightness: undefined,
  };
}

export const Notification: MessageFns<Notification> = {
  encode(message: Notification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== 0) {
      writer.uint32(8).int32(message.event);
    }
    if (message.cameraNotification !== undefined) {
      CameraNotification.encode(message.cameraNotification, writer.uint32(18).fork()).join();
    }
    if (message.displayConfigurationsChangedNotification !== undefined) {
      DisplayConfigurationsChangedNotification.encode(
        message.displayConfigurationsChangedNotification,
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.posture !== undefined) {
      Posture.encode(message.posture, writer.uint32(34).fork()).join();
    }
    if (message.booted !== undefined) {
      BootCompletedNotification.encode(message.booted, writer.uint32(42).fork()).join();
    }
    if (message.brightness !== undefined) {
      BrightnessValue.encode(message.brightness, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Notification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.event = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cameraNotification = CameraNotification.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayConfigurationsChangedNotification = DisplayConfigurationsChangedNotification.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.posture = Posture.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.booted = BootCompletedNotification.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.brightness = BrightnessValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Notification {
    return {
      event: isSet(object.event) ? notification_EventTypeFromJSON(object.event) : 0,
      cameraNotification: isSet(object.cameraNotification)
        ? CameraNotification.fromJSON(object.cameraNotification)
        : undefined,
      displayConfigurationsChangedNotification: isSet(object.displayConfigurationsChangedNotification)
        ? DisplayConfigurationsChangedNotification.fromJSON(object.displayConfigurationsChangedNotification)
        : undefined,
      posture: isSet(object.posture) ? Posture.fromJSON(object.posture) : undefined,
      booted: isSet(object.booted) ? BootCompletedNotification.fromJSON(object.booted) : undefined,
      brightness: isSet(object.brightness) ? BrightnessValue.fromJSON(object.brightness) : undefined,
    };
  },

  toJSON(message: Notification): unknown {
    const obj: any = {};
    if (message.event !== 0) {
      obj.event = notification_EventTypeToJSON(message.event);
    }
    if (message.cameraNotification !== undefined) {
      obj.cameraNotification = CameraNotification.toJSON(message.cameraNotification);
    }
    if (message.displayConfigurationsChangedNotification !== undefined) {
      obj.displayConfigurationsChangedNotification = DisplayConfigurationsChangedNotification.toJSON(
        message.displayConfigurationsChangedNotification,
      );
    }
    if (message.posture !== undefined) {
      obj.posture = Posture.toJSON(message.posture);
    }
    if (message.booted !== undefined) {
      obj.booted = BootCompletedNotification.toJSON(message.booted);
    }
    if (message.brightness !== undefined) {
      obj.brightness = BrightnessValue.toJSON(message.brightness);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Notification>, I>>(base?: I): Notification {
    return Notification.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Notification>, I>>(object: I): Notification {
    const message = createBaseNotification();
    message.event = object.event ?? 0;
    message.cameraNotification = (object.cameraNotification !== undefined && object.cameraNotification !== null)
      ? CameraNotification.fromPartial(object.cameraNotification)
      : undefined;
    message.displayConfigurationsChangedNotification =
      (object.displayConfigurationsChangedNotification !== undefined &&
          object.displayConfigurationsChangedNotification !== null)
        ? DisplayConfigurationsChangedNotification.fromPartial(object.displayConfigurationsChangedNotification)
        : undefined;
    message.posture = (object.posture !== undefined && object.posture !== null)
      ? Posture.fromPartial(object.posture)
      : undefined;
    message.booted = (object.booted !== undefined && object.booted !== null)
      ? BootCompletedNotification.fromPartial(object.booted)
      : undefined;
    message.brightness = (object.brightness !== undefined && object.brightness !== null)
      ? BrightnessValue.fromPartial(object.brightness)
      : undefined;
    return message;
  },
};

function createBaseBootCompletedNotification(): BootCompletedNotification {
  return { time: 0 };
}

export const BootCompletedNotification: MessageFns<BootCompletedNotification> = {
  encode(message: BootCompletedNotification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== 0) {
      writer.uint32(8).int32(message.time);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BootCompletedNotification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootCompletedNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.time = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BootCompletedNotification {
    return { time: isSet(object.time) ? globalThis.Number(object.time) : 0 };
  },

  toJSON(message: BootCompletedNotification): unknown {
    const obj: any = {};
    if (message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BootCompletedNotification>, I>>(base?: I): BootCompletedNotification {
    return BootCompletedNotification.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BootCompletedNotification>, I>>(object: I): BootCompletedNotification {
    const message = createBaseBootCompletedNotification();
    message.time = object.time ?? 0;
    return message;
  },
};

function createBaseCameraNotification(): CameraNotification {
  return { active: false, display: 0 };
}

export const CameraNotification: MessageFns<CameraNotification> = {
  encode(message: CameraNotification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.active !== false) {
      writer.uint32(8).bool(message.active);
    }
    if (message.display !== 0) {
      writer.uint32(16).int32(message.display);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CameraNotification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCameraNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.display = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CameraNotification {
    return {
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
      display: isSet(object.display) ? globalThis.Number(object.display) : 0,
    };
  },

  toJSON(message: CameraNotification): unknown {
    const obj: any = {};
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (message.display !== 0) {
      obj.display = Math.round(message.display);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CameraNotification>, I>>(base?: I): CameraNotification {
    return CameraNotification.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CameraNotification>, I>>(object: I): CameraNotification {
    const message = createBaseCameraNotification();
    message.active = object.active ?? false;
    message.display = object.display ?? 0;
    return message;
  },
};

function createBaseDisplayConfigurationsChangedNotification(): DisplayConfigurationsChangedNotification {
  return { displayConfigurations: undefined };
}

export const DisplayConfigurationsChangedNotification: MessageFns<DisplayConfigurationsChangedNotification> = {
  encode(message: DisplayConfigurationsChangedNotification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayConfigurations !== undefined) {
      DisplayConfigurations.encode(message.displayConfigurations, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisplayConfigurationsChangedNotification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisplayConfigurationsChangedNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayConfigurations = DisplayConfigurations.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisplayConfigurationsChangedNotification {
    return {
      displayConfigurations: isSet(object.displayConfigurations)
        ? DisplayConfigurations.fromJSON(object.displayConfigurations)
        : undefined,
    };
  },

  toJSON(message: DisplayConfigurationsChangedNotification): unknown {
    const obj: any = {};
    if (message.displayConfigurations !== undefined) {
      obj.displayConfigurations = DisplayConfigurations.toJSON(message.displayConfigurations);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DisplayConfigurationsChangedNotification>, I>>(
    base?: I,
  ): DisplayConfigurationsChangedNotification {
    return DisplayConfigurationsChangedNotification.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisplayConfigurationsChangedNotification>, I>>(
    object: I,
  ): DisplayConfigurationsChangedNotification {
    const message = createBaseDisplayConfigurationsChangedNotification();
    message.displayConfigurations =
      (object.displayConfigurations !== undefined && object.displayConfigurations !== null)
        ? DisplayConfigurations.fromPartial(object.displayConfigurations)
        : undefined;
    return message;
  },
};

function createBaseRotationRadian(): RotationRadian {
  return { x: 0, y: 0, z: 0 };
}

export const RotationRadian: MessageFns<RotationRadian> = {
  encode(message: RotationRadian, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RotationRadian {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRotationRadian();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RotationRadian {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
    };
  },

  toJSON(message: RotationRadian): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RotationRadian>, I>>(base?: I): RotationRadian {
    return RotationRadian.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RotationRadian>, I>>(object: I): RotationRadian {
    const message = createBaseRotationRadian();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    return message;
  },
};

function createBaseVelocity(): Velocity {
  return { x: 0, y: 0, z: 0 };
}

export const Velocity: MessageFns<Velocity> = {
  encode(message: Velocity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Velocity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVelocity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Velocity {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
    };
  },

  toJSON(message: Velocity): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Velocity>, I>>(base?: I): Velocity {
    return Velocity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Velocity>, I>>(object: I): Velocity {
    const message = createBaseVelocity();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    return message;
  },
};

function createBasePosture(): Posture {
  return { value: 0 };
}

export const Posture: MessageFns<Posture> = {
  encode(message: Posture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(24).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Posture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePosture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Posture {
    return { value: isSet(object.value) ? posture_PostureValueFromJSON(object.value) : 0 };
  },

  toJSON(message: Posture): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = posture_PostureValueToJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Posture>, I>>(base?: I): Posture {
    return Posture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Posture>, I>>(object: I): Posture {
    const message = createBasePosture();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBasePhoneNumber(): PhoneNumber {
  return { number: "" };
}

export const PhoneNumber: MessageFns<PhoneNumber> = {
  encode(message: PhoneNumber, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== "") {
      writer.uint32(10).string(message.number);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhoneNumber {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhoneNumber();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.number = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhoneNumber {
    return { number: isSet(object.number) ? globalThis.String(object.number) : "" };
  },

  toJSON(message: PhoneNumber): unknown {
    const obj: any = {};
    if (message.number !== "") {
      obj.number = message.number;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PhoneNumber>, I>>(base?: I): PhoneNumber {
    return PhoneNumber.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PhoneNumber>, I>>(object: I): PhoneNumber {
    const message = createBasePhoneNumber();
    message.number = object.number ?? "";
    return message;
  },
};

/**
 * An EmulatorController service lets you control the emulator.
 * Note that this is currently an experimental feature, and that the
 * service definition might change without notice. Use at your own risk!
 *
 * We use the following rough conventions:
 *
 * streamXXX --> streams values XXX (usually for emulator lifetime). Values
 *               are updated as soon as they become available.
 * getXXX    --> gets a single value XXX
 * setXXX    --> sets a single value XXX, does not returning state, these
 *               usually have an observable lasting side effect.
 * sendXXX   --> send a single event XXX, possibly returning state information.
 *               android usually responds to these events.
 */
export type EmulatorControllerService = typeof EmulatorControllerService;
export const EmulatorControllerService = {
  /** set/get/stream the sensor data */
  streamSensor: {
    path: "/android.emulation.control.EmulatorController/streamSensor",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SensorValue): Buffer => Buffer.from(SensorValue.encode(value).finish()),
    requestDeserialize: (value: Buffer): SensorValue => SensorValue.decode(value),
    responseSerialize: (value: SensorValue): Buffer => Buffer.from(SensorValue.encode(value).finish()),
    responseDeserialize: (value: Buffer): SensorValue => SensorValue.decode(value),
  },
  getSensor: {
    path: "/android.emulation.control.EmulatorController/getSensor",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SensorValue): Buffer => Buffer.from(SensorValue.encode(value).finish()),
    requestDeserialize: (value: Buffer): SensorValue => SensorValue.decode(value),
    responseSerialize: (value: SensorValue): Buffer => Buffer.from(SensorValue.encode(value).finish()),
    responseDeserialize: (value: Buffer): SensorValue => SensorValue.decode(value),
  },
  setSensor: {
    path: "/android.emulation.control.EmulatorController/setSensor",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SensorValue): Buffer => Buffer.from(SensorValue.encode(value).finish()),
    requestDeserialize: (value: Buffer): SensorValue => SensorValue.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /**
   * set/get/stream the physical model, this is likely the one you are
   * looking for when you wish to modify the device state.
   */
  setPhysicalModel: {
    path: "/android.emulation.control.EmulatorController/setPhysicalModel",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PhysicalModelValue): Buffer => Buffer.from(PhysicalModelValue.encode(value).finish()),
    requestDeserialize: (value: Buffer): PhysicalModelValue => PhysicalModelValue.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  getPhysicalModel: {
    path: "/android.emulation.control.EmulatorController/getPhysicalModel",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PhysicalModelValue): Buffer => Buffer.from(PhysicalModelValue.encode(value).finish()),
    requestDeserialize: (value: Buffer): PhysicalModelValue => PhysicalModelValue.decode(value),
    responseSerialize: (value: PhysicalModelValue): Buffer => Buffer.from(PhysicalModelValue.encode(value).finish()),
    responseDeserialize: (value: Buffer): PhysicalModelValue => PhysicalModelValue.decode(value),
  },
  streamPhysicalModel: {
    path: "/android.emulation.control.EmulatorController/streamPhysicalModel",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: PhysicalModelValue): Buffer => Buffer.from(PhysicalModelValue.encode(value).finish()),
    requestDeserialize: (value: Buffer): PhysicalModelValue => PhysicalModelValue.decode(value),
    responseSerialize: (value: PhysicalModelValue): Buffer => Buffer.from(PhysicalModelValue.encode(value).finish()),
    responseDeserialize: (value: Buffer): PhysicalModelValue => PhysicalModelValue.decode(value),
  },
  /**
   * Atomically set/get the current primary clipboard data.
   * Note that a call to setClipboard will result in an immediate
   * event for those who made a call to streamClipboard and are
   * on a different channel than the one used to set the clipboard.
   */
  setClipboard: {
    path: "/android.emulation.control.EmulatorController/setClipboard",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ClipData): Buffer => Buffer.from(ClipData.encode(value).finish()),
    requestDeserialize: (value: Buffer): ClipData => ClipData.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  getClipboard: {
    path: "/android.emulation.control.EmulatorController/getClipboard",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: ClipData): Buffer => Buffer.from(ClipData.encode(value).finish()),
    responseDeserialize: (value: Buffer): ClipData => ClipData.decode(value),
  },
  /**
   * Streams the current data on the clipboard. This will immediately produce
   * a result with the current state of the clipboard after which the stream
   * will block and wait until a new clip event is available from the guest.
   * Calling the setClipboard method above will not result in generating a
   * clip event. It is possible to lose clipboard events if the clipboard
   * updates very rapidly.
   */
  streamClipboard: {
    path: "/android.emulation.control.EmulatorController/streamClipboard",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: ClipData): Buffer => Buffer.from(ClipData.encode(value).finish()),
    responseDeserialize: (value: Buffer): ClipData => ClipData.decode(value),
  },
  /** Set/get the battery to the given state. */
  setBattery: {
    path: "/android.emulation.control.EmulatorController/setBattery",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BatteryState): Buffer => Buffer.from(BatteryState.encode(value).finish()),
    requestDeserialize: (value: Buffer): BatteryState => BatteryState.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  getBattery: {
    path: "/android.emulation.control.EmulatorController/getBattery",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: BatteryState): Buffer => Buffer.from(BatteryState.encode(value).finish()),
    responseDeserialize: (value: Buffer): BatteryState => BatteryState.decode(value),
  },
  /**
   * Set the state of the gps.
   * Note: Setting the gps position will not be reflected in the user
   * interface. Keep in mind that android usually only samples the gps at 1
   * hz.
   */
  setGps: {
    path: "/android.emulation.control.EmulatorController/setGps",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GpsState): Buffer => Buffer.from(GpsState.encode(value).finish()),
    requestDeserialize: (value: Buffer): GpsState => GpsState.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /**
   * Gets the latest gps state as delivered by the setGps call, or location ui
   * if active.
   *
   * Note: this is not necessarily the actual gps coordinate visible at the
   * time, due to gps sample frequency (usually 1hz).
   */
  getGps: {
    path: "/android.emulation.control.EmulatorController/getGps",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: GpsState): Buffer => Buffer.from(GpsState.encode(value).finish()),
    responseDeserialize: (value: Buffer): GpsState => GpsState.decode(value),
  },
  /** Simulate a touch event on the finger print sensor. */
  sendFingerprint: {
    path: "/android.emulation.control.EmulatorController/sendFingerprint",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Fingerprint): Buffer => Buffer.from(Fingerprint.encode(value).finish()),
    requestDeserialize: (value: Buffer): Fingerprint => Fingerprint.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /** Send a keyboard event. Translating the event. */
  sendKey: {
    path: "/android.emulation.control.EmulatorController/sendKey",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: KeyboardEvent): Buffer => Buffer.from(KeyboardEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer): KeyboardEvent => KeyboardEvent.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /**
   * Send touch/mouse events. Note that mouse events can be simulated
   * by touch events.
   */
  sendTouch: {
    path: "/android.emulation.control.EmulatorController/sendTouch",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TouchEvent): Buffer => Buffer.from(TouchEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer): TouchEvent => TouchEvent.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  sendMouse: {
    path: "/android.emulation.control.EmulatorController/sendMouse",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MouseEvent): Buffer => Buffer.from(MouseEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer): MouseEvent => MouseEvent.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  injectWheel: {
    path: "/android.emulation.control.EmulatorController/injectWheel",
    requestStream: true,
    responseStream: false,
    requestSerialize: (value: WheelEvent): Buffer => Buffer.from(WheelEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer): WheelEvent => WheelEvent.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /**
   * Stream a series of input events to the emulator, the events will
   * arrive in order.
   */
  streamInputEvent: {
    path: "/android.emulation.control.EmulatorController/streamInputEvent",
    requestStream: true,
    responseStream: false,
    requestSerialize: (value: InputEvent): Buffer => Buffer.from(InputEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer): InputEvent => InputEvent.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /** Make a phone call. */
  sendPhone: {
    path: "/android.emulation.control.EmulatorController/sendPhone",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PhoneCall): Buffer => Buffer.from(PhoneCall.encode(value).finish()),
    requestDeserialize: (value: Buffer): PhoneCall => PhoneCall.decode(value),
    responseSerialize: (value: PhoneResponse): Buffer => Buffer.from(PhoneResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PhoneResponse => PhoneResponse.decode(value),
  },
  /** Sends an sms message to the emulator. */
  sendSms: {
    path: "/android.emulation.control.EmulatorController/sendSms",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SmsMessage): Buffer => Buffer.from(SmsMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer): SmsMessage => SmsMessage.decode(value),
    responseSerialize: (value: PhoneResponse): Buffer => Buffer.from(PhoneResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PhoneResponse => PhoneResponse.decode(value),
  },
  /** Sends an sms message to the emulator. */
  setPhoneNumber: {
    path: "/android.emulation.control.EmulatorController/setPhoneNumber",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PhoneNumber): Buffer => Buffer.from(PhoneNumber.encode(value).finish()),
    requestDeserialize: (value: Buffer): PhoneNumber => PhoneNumber.decode(value),
    responseSerialize: (value: PhoneResponse): Buffer => Buffer.from(PhoneResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PhoneResponse => PhoneResponse.decode(value),
  },
  /**
   * Retrieve the status of the emulator. This will contain general
   * hardware information, and whether the device has booted or not.
   */
  getStatus: {
    path: "/android.emulation.control.EmulatorController/getStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: EmulatorStatus): Buffer => Buffer.from(EmulatorStatus.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmulatorStatus => EmulatorStatus.decode(value),
  },
  /**
   * Gets an individual screenshot in the desired format.
   *
   * The image will be scaled to the desired ImageFormat, while maintaining
   * the aspect ratio. The returned image will never exceed resolution of the
   * device display. Not setting the width or height (i.e. they are 0) will
   * result in using the display width and height.
   *
   * The resulting image will be properly oriented and can be displayed
   * directly without post processing. For example, if the device has a
   * 1080x1920 screen and is in landscape mode and called with no width or
   * height parameter, it will return a 1920x1080 image.
   *
   * The dimensions of the returned image will never exceed the corresponding
   * display dimensions. For example, this method will return a 1920x1080
   * screenshot, if the display resolution is 1080x1920 and a screenshot of
   * 2048x2048 is requested when the device is in landscape mode.
   *
   * This method will return an empty image if the display is not visible.
   */
  getScreenshot: {
    path: "/android.emulation.control.EmulatorController/getScreenshot",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ImageFormat): Buffer => Buffer.from(ImageFormat.encode(value).finish()),
    requestDeserialize: (value: Buffer): ImageFormat => ImageFormat.decode(value),
    responseSerialize: (value: Image): Buffer => Buffer.from(Image.encode(value).finish()),
    responseDeserialize: (value: Buffer): Image => Image.decode(value),
  },
  /**
   * Streams a series of screenshots in the desired format.
   *
   * A new frame will be delivered whenever the device produces a new frame.
   * Beware that this can produce a significant amount of data and that
   * certain translations can be very costly. For example, streaming a series
   * of png images is very cpu intensive.
   *
   * Images are produced according to the getScreenshot API described above.
   *
   * If the display is inactive, or becomes inactive, an empty image will be
   * delivered. Images will be delived again if the display becomes active and
   * new frames are produced.
   */
  streamScreenshot: {
    path: "/android.emulation.control.EmulatorController/streamScreenshot",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ImageFormat): Buffer => Buffer.from(ImageFormat.encode(value).finish()),
    requestDeserialize: (value: Buffer): ImageFormat => ImageFormat.decode(value),
    responseSerialize: (value: Image): Buffer => Buffer.from(Image.encode(value).finish()),
    responseDeserialize: (value: Buffer): Image => Image.decode(value),
  },
  /**
   * Streams a series of audio packets in the desired format.
   * A new frame will be delivered whenever the emulated device
   * produces a new audio frame. You can expect packets to be
   * delivered in intervals of 20-30ms.
   *
   * Be aware that this can block when the emulator does not
   * produce any audio whatsoever!
   */
  streamAudio: {
    path: "/android.emulation.control.EmulatorController/streamAudio",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: AudioFormat): Buffer => Buffer.from(AudioFormat.encode(value).finish()),
    requestDeserialize: (value: Buffer): AudioFormat => AudioFormat.decode(value),
    responseSerialize: (value: AudioPacket): Buffer => Buffer.from(AudioPacket.encode(value).finish()),
    responseDeserialize: (value: Buffer): AudioPacket => AudioPacket.decode(value),
  },
  /**
   * Injects a series of audio packets to the android microphone.
   * A new frame will be delivered whenever the emulated device
   * requests a new audio frame. Audio is usually delivered at a rate
   * that the emulator is requesting frames. Audio will be stored in a
   * temporary buffer that can hold 300ms of audio.
   *
   * Notes:
   *  - Only the first audio format packet that is delivered will be
   * honored. There is no need to send the audio format multiple times.
   *  - Real time audio currently immediately overrides the buffer. This
   * means you must provide a constant rate of audio packets. The real
   * time mode is experimental. Timestamps of audio packets might be
   * used in the future to improve synchronization.
   *
   * -  INVALID_ARGUMENT (code 3) The sampling rate was too high/low
   * -  INVALID_ARGUMENT (code 3) The audio packet was too large to handle.
   * -  FAILED_PRECONDITION (code 9) If there was a microphone registered
   * already.
   */
  injectAudio: {
    path: "/android.emulation.control.EmulatorController/injectAudio",
    requestStream: true,
    responseStream: false,
    requestSerialize: (value: AudioPacket): Buffer => Buffer.from(AudioPacket.encode(value).finish()),
    requestDeserialize: (value: Buffer): AudioPacket => AudioPacket.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /**
   * Deprecated, please use the streamLogcat method instead.
   *
   * @deprecated
   */
  getLogcat: {
    path: "/android.emulation.control.EmulatorController/getLogcat",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LogMessage): Buffer => Buffer.from(LogMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer): LogMessage => LogMessage.decode(value),
    responseSerialize: (value: LogMessage): Buffer => Buffer.from(LogMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer): LogMessage => LogMessage.decode(value),
  },
  /**
   * Streams the logcat output from the emulator.
   * Note that parsed logcat messages are only available after L (Api >23)
   */
  streamLogcat: {
    path: "/android.emulation.control.EmulatorController/streamLogcat",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: LogMessage): Buffer => Buffer.from(LogMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer): LogMessage => LogMessage.decode(value),
    responseSerialize: (value: LogMessage): Buffer => Buffer.from(LogMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer): LogMessage => LogMessage.decode(value),
  },
  /**
   * Transition the virtual machine to the desired state. Note that
   * some states are only observable. For example you cannot transition
   * to the error state.
   */
  setVmState: {
    path: "/android.emulation.control.EmulatorController/setVmState",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VmRunState): Buffer => Buffer.from(VmRunState.encode(value).finish()),
    requestDeserialize: (value: Buffer): VmRunState => VmRunState.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /** Gets the state of the virtual machine. */
  getVmState: {
    path: "/android.emulation.control.EmulatorController/getVmState",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: VmRunState): Buffer => Buffer.from(VmRunState.encode(value).finish()),
    responseDeserialize: (value: Buffer): VmRunState => VmRunState.decode(value),
  },
  /**
   * Atomically changes the current multi-display configuration.
   * After this call the given display configurations will be activated. You
   * can only update secondary displays. Displays with id 0 will be ignored.
   *
   * This call can result in the removal or addition of secondary displays,
   * the final display state can be observed by the returned configuration.
   *
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD does not support a
   * configurable
   *    secondary display.
   * -  INVALID_ARGUMENT (code 3) if:
   *     - The same display id is defined multiple times.
   *     - The display configurations are outside valid ranges.
   *       See DisplayConfiguration for details on valid ranges.
   * -  INTERNAL (code 13) if there was an internal emulator failure.
   */
  setDisplayConfigurations: {
    path: "/android.emulation.control.EmulatorController/setDisplayConfigurations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DisplayConfigurations): Buffer =>
      Buffer.from(DisplayConfigurations.encode(value).finish()),
    requestDeserialize: (value: Buffer): DisplayConfigurations => DisplayConfigurations.decode(value),
    responseSerialize: (value: DisplayConfigurations): Buffer =>
      Buffer.from(DisplayConfigurations.encode(value).finish()),
    responseDeserialize: (value: Buffer): DisplayConfigurations => DisplayConfigurations.decode(value),
  },
  /**
   * Returns all currently valid logical displays.
   *
   * The gRPC error code FAILED_PRECONDITION (code 9) is returned if the AVD
   * does not support a configurable secondary display.
   */
  getDisplayConfigurations: {
    path: "/android.emulation.control.EmulatorController/getDisplayConfigurations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: DisplayConfigurations): Buffer =>
      Buffer.from(DisplayConfigurations.encode(value).finish()),
    responseDeserialize: (value: Buffer): DisplayConfigurations => DisplayConfigurations.decode(value),
  },
  /**
   * Notifies client of the following changes:
   *
   * - Virtual scene camera status change.
   * - Display configuration changes from extended ui. This will only be fired
   *   if the user makes modifications the extended displays through the
   *   extended control tab.
   *
   * Note that this method will send the initial virtual scene state
   * immediately.
   */
  streamNotification: {
    path: "/android.emulation.control.EmulatorController/streamNotification",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: Notification): Buffer => Buffer.from(Notification.encode(value).finish()),
    responseDeserialize: (value: Buffer): Notification => Notification.decode(value),
  },
  /**
   * Rotation angles are relative to the camera's current orientation.
   * The coordinate system is right-handed and is defined as follows:
   *   x axis is pointing right
   *   y axis is pointing up
   *   z axis is pointing towards the viewer
   * The z component of rotation is not used when calling this method.
   */
  rotateVirtualSceneCamera: {
    path: "/android.emulation.control.EmulatorController/rotateVirtualSceneCamera",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RotationRadian): Buffer => Buffer.from(RotationRadian.encode(value).finish()),
    requestDeserialize: (value: Buffer): RotationRadian => RotationRadian.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /**
   * Velocity is absolute and is measured in meters per second.
   * The coordinate system is right-handed and is defined as follows:
   *   x axis is pointing right
   *   y axis is pointing up
   *   z axis is pointing towards the viewer
   */
  setVirtualSceneCameraVelocity: {
    path: "/android.emulation.control.EmulatorController/setVirtualSceneCameraVelocity",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Velocity): Buffer => Buffer.from(Velocity.encode(value).finish()),
    requestDeserialize: (value: Buffer): Velocity => Velocity.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /** Set foldable posture */
  setPosture: {
    path: "/android.emulation.control.EmulatorController/setPosture",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Posture): Buffer => Buffer.from(Posture.encode(value).finish()),
    requestDeserialize: (value: Buffer): Posture => Posture.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /**
   * Get the backlight brightness.
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD does not support hw-control.
   */
  getBrightness: {
    path: "/android.emulation.control.EmulatorController/getBrightness",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BrightnessValue): Buffer => Buffer.from(BrightnessValue.encode(value).finish()),
    requestDeserialize: (value: Buffer): BrightnessValue => BrightnessValue.decode(value),
    responseSerialize: (value: BrightnessValue): Buffer => Buffer.from(BrightnessValue.encode(value).finish()),
    responseDeserialize: (value: Buffer): BrightnessValue => BrightnessValue.decode(value),
  },
  /**
   * Set the backlight brightness.
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD does not support hw-control.
   * -  INVALID_ARGUMENT (code 3) The brightness exceeds the valid range.
   */
  setBrightness: {
    path: "/android.emulation.control.EmulatorController/setBrightness",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BrightnessValue): Buffer => Buffer.from(BrightnessValue.encode(value).finish()),
    requestDeserialize: (value: Buffer): BrightnessValue => BrightnessValue.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /**
   * Returns the current mode of the primary display of a resizable AVD.
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD is not resizable.
   */
  getDisplayMode: {
    path: "/android.emulation.control.EmulatorController/getDisplayMode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: DisplayMode): Buffer => Buffer.from(DisplayMode.encode(value).finish()),
    responseDeserialize: (value: Buffer): DisplayMode => DisplayMode.decode(value),
  },
  /**
   * Sets the size of the primary display of a resizable AVD. Fails if the AVD
   * is not resizable. The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD is not resizable.
   */
  setDisplayMode: {
    path: "/android.emulation.control.EmulatorController/setDisplayMode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DisplayMode): Buffer => Buffer.from(DisplayMode.encode(value).finish()),
    requestDeserialize: (value: Buffer): DisplayMode => DisplayMode.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
} as const;

export interface EmulatorControllerServer extends UntypedServiceImplementation {
  /** set/get/stream the sensor data */
  streamSensor: handleServerStreamingCall<SensorValue, SensorValue>;
  getSensor: handleUnaryCall<SensorValue, SensorValue>;
  setSensor: handleUnaryCall<SensorValue, Empty>;
  /**
   * set/get/stream the physical model, this is likely the one you are
   * looking for when you wish to modify the device state.
   */
  setPhysicalModel: handleUnaryCall<PhysicalModelValue, Empty>;
  getPhysicalModel: handleUnaryCall<PhysicalModelValue, PhysicalModelValue>;
  streamPhysicalModel: handleServerStreamingCall<PhysicalModelValue, PhysicalModelValue>;
  /**
   * Atomically set/get the current primary clipboard data.
   * Note that a call to setClipboard will result in an immediate
   * event for those who made a call to streamClipboard and are
   * on a different channel than the one used to set the clipboard.
   */
  setClipboard: handleUnaryCall<ClipData, Empty>;
  getClipboard: handleUnaryCall<Empty, ClipData>;
  /**
   * Streams the current data on the clipboard. This will immediately produce
   * a result with the current state of the clipboard after which the stream
   * will block and wait until a new clip event is available from the guest.
   * Calling the setClipboard method above will not result in generating a
   * clip event. It is possible to lose clipboard events if the clipboard
   * updates very rapidly.
   */
  streamClipboard: handleServerStreamingCall<Empty, ClipData>;
  /** Set/get the battery to the given state. */
  setBattery: handleUnaryCall<BatteryState, Empty>;
  getBattery: handleUnaryCall<Empty, BatteryState>;
  /**
   * Set the state of the gps.
   * Note: Setting the gps position will not be reflected in the user
   * interface. Keep in mind that android usually only samples the gps at 1
   * hz.
   */
  setGps: handleUnaryCall<GpsState, Empty>;
  /**
   * Gets the latest gps state as delivered by the setGps call, or location ui
   * if active.
   *
   * Note: this is not necessarily the actual gps coordinate visible at the
   * time, due to gps sample frequency (usually 1hz).
   */
  getGps: handleUnaryCall<Empty, GpsState>;
  /** Simulate a touch event on the finger print sensor. */
  sendFingerprint: handleUnaryCall<Fingerprint, Empty>;
  /** Send a keyboard event. Translating the event. */
  sendKey: handleUnaryCall<KeyboardEvent, Empty>;
  /**
   * Send touch/mouse events. Note that mouse events can be simulated
   * by touch events.
   */
  sendTouch: handleUnaryCall<TouchEvent, Empty>;
  sendMouse: handleUnaryCall<MouseEvent, Empty>;
  injectWheel: handleClientStreamingCall<WheelEvent, Empty>;
  /**
   * Stream a series of input events to the emulator, the events will
   * arrive in order.
   */
  streamInputEvent: handleClientStreamingCall<InputEvent, Empty>;
  /** Make a phone call. */
  sendPhone: handleUnaryCall<PhoneCall, PhoneResponse>;
  /** Sends an sms message to the emulator. */
  sendSms: handleUnaryCall<SmsMessage, PhoneResponse>;
  /** Sends an sms message to the emulator. */
  setPhoneNumber: handleUnaryCall<PhoneNumber, PhoneResponse>;
  /**
   * Retrieve the status of the emulator. This will contain general
   * hardware information, and whether the device has booted or not.
   */
  getStatus: handleUnaryCall<Empty, EmulatorStatus>;
  /**
   * Gets an individual screenshot in the desired format.
   *
   * The image will be scaled to the desired ImageFormat, while maintaining
   * the aspect ratio. The returned image will never exceed resolution of the
   * device display. Not setting the width or height (i.e. they are 0) will
   * result in using the display width and height.
   *
   * The resulting image will be properly oriented and can be displayed
   * directly without post processing. For example, if the device has a
   * 1080x1920 screen and is in landscape mode and called with no width or
   * height parameter, it will return a 1920x1080 image.
   *
   * The dimensions of the returned image will never exceed the corresponding
   * display dimensions. For example, this method will return a 1920x1080
   * screenshot, if the display resolution is 1080x1920 and a screenshot of
   * 2048x2048 is requested when the device is in landscape mode.
   *
   * This method will return an empty image if the display is not visible.
   */
  getScreenshot: handleUnaryCall<ImageFormat, Image>;
  /**
   * Streams a series of screenshots in the desired format.
   *
   * A new frame will be delivered whenever the device produces a new frame.
   * Beware that this can produce a significant amount of data and that
   * certain translations can be very costly. For example, streaming a series
   * of png images is very cpu intensive.
   *
   * Images are produced according to the getScreenshot API described above.
   *
   * If the display is inactive, or becomes inactive, an empty image will be
   * delivered. Images will be delived again if the display becomes active and
   * new frames are produced.
   */
  streamScreenshot: handleServerStreamingCall<ImageFormat, Image>;
  /**
   * Streams a series of audio packets in the desired format.
   * A new frame will be delivered whenever the emulated device
   * produces a new audio frame. You can expect packets to be
   * delivered in intervals of 20-30ms.
   *
   * Be aware that this can block when the emulator does not
   * produce any audio whatsoever!
   */
  streamAudio: handleServerStreamingCall<AudioFormat, AudioPacket>;
  /**
   * Injects a series of audio packets to the android microphone.
   * A new frame will be delivered whenever the emulated device
   * requests a new audio frame. Audio is usually delivered at a rate
   * that the emulator is requesting frames. Audio will be stored in a
   * temporary buffer that can hold 300ms of audio.
   *
   * Notes:
   *  - Only the first audio format packet that is delivered will be
   * honored. There is no need to send the audio format multiple times.
   *  - Real time audio currently immediately overrides the buffer. This
   * means you must provide a constant rate of audio packets. The real
   * time mode is experimental. Timestamps of audio packets might be
   * used in the future to improve synchronization.
   *
   * -  INVALID_ARGUMENT (code 3) The sampling rate was too high/low
   * -  INVALID_ARGUMENT (code 3) The audio packet was too large to handle.
   * -  FAILED_PRECONDITION (code 9) If there was a microphone registered
   * already.
   */
  injectAudio: handleClientStreamingCall<AudioPacket, Empty>;
  /**
   * Deprecated, please use the streamLogcat method instead.
   *
   * @deprecated
   */
  getLogcat: handleUnaryCall<LogMessage, LogMessage>;
  /**
   * Streams the logcat output from the emulator.
   * Note that parsed logcat messages are only available after L (Api >23)
   */
  streamLogcat: handleServerStreamingCall<LogMessage, LogMessage>;
  /**
   * Transition the virtual machine to the desired state. Note that
   * some states are only observable. For example you cannot transition
   * to the error state.
   */
  setVmState: handleUnaryCall<VmRunState, Empty>;
  /** Gets the state of the virtual machine. */
  getVmState: handleUnaryCall<Empty, VmRunState>;
  /**
   * Atomically changes the current multi-display configuration.
   * After this call the given display configurations will be activated. You
   * can only update secondary displays. Displays with id 0 will be ignored.
   *
   * This call can result in the removal or addition of secondary displays,
   * the final display state can be observed by the returned configuration.
   *
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD does not support a
   * configurable
   *    secondary display.
   * -  INVALID_ARGUMENT (code 3) if:
   *     - The same display id is defined multiple times.
   *     - The display configurations are outside valid ranges.
   *       See DisplayConfiguration for details on valid ranges.
   * -  INTERNAL (code 13) if there was an internal emulator failure.
   */
  setDisplayConfigurations: handleUnaryCall<DisplayConfigurations, DisplayConfigurations>;
  /**
   * Returns all currently valid logical displays.
   *
   * The gRPC error code FAILED_PRECONDITION (code 9) is returned if the AVD
   * does not support a configurable secondary display.
   */
  getDisplayConfigurations: handleUnaryCall<Empty, DisplayConfigurations>;
  /**
   * Notifies client of the following changes:
   *
   * - Virtual scene camera status change.
   * - Display configuration changes from extended ui. This will only be fired
   *   if the user makes modifications the extended displays through the
   *   extended control tab.
   *
   * Note that this method will send the initial virtual scene state
   * immediately.
   */
  streamNotification: handleServerStreamingCall<Empty, Notification>;
  /**
   * Rotation angles are relative to the camera's current orientation.
   * The coordinate system is right-handed and is defined as follows:
   *   x axis is pointing right
   *   y axis is pointing up
   *   z axis is pointing towards the viewer
   * The z component of rotation is not used when calling this method.
   */
  rotateVirtualSceneCamera: handleUnaryCall<RotationRadian, Empty>;
  /**
   * Velocity is absolute and is measured in meters per second.
   * The coordinate system is right-handed and is defined as follows:
   *   x axis is pointing right
   *   y axis is pointing up
   *   z axis is pointing towards the viewer
   */
  setVirtualSceneCameraVelocity: handleUnaryCall<Velocity, Empty>;
  /** Set foldable posture */
  setPosture: handleUnaryCall<Posture, Empty>;
  /**
   * Get the backlight brightness.
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD does not support hw-control.
   */
  getBrightness: handleUnaryCall<BrightnessValue, BrightnessValue>;
  /**
   * Set the backlight brightness.
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD does not support hw-control.
   * -  INVALID_ARGUMENT (code 3) The brightness exceeds the valid range.
   */
  setBrightness: handleUnaryCall<BrightnessValue, Empty>;
  /**
   * Returns the current mode of the primary display of a resizable AVD.
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD is not resizable.
   */
  getDisplayMode: handleUnaryCall<Empty, DisplayMode>;
  /**
   * Sets the size of the primary display of a resizable AVD. Fails if the AVD
   * is not resizable. The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD is not resizable.
   */
  setDisplayMode: handleUnaryCall<DisplayMode, Empty>;
}

export interface EmulatorControllerClient extends Client {
  /** set/get/stream the sensor data */
  streamSensor(request: SensorValue, options?: Partial<CallOptions>): ClientReadableStream<SensorValue>;
  streamSensor(
    request: SensorValue,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<SensorValue>;
  getSensor(
    request: SensorValue,
    callback: (error: ServiceError | null, response: SensorValue) => void,
  ): ClientUnaryCall;
  getSensor(
    request: SensorValue,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SensorValue) => void,
  ): ClientUnaryCall;
  getSensor(
    request: SensorValue,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SensorValue) => void,
  ): ClientUnaryCall;
  setSensor(request: SensorValue, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  setSensor(
    request: SensorValue,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  setSensor(
    request: SensorValue,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /**
   * set/get/stream the physical model, this is likely the one you are
   * looking for when you wish to modify the device state.
   */
  setPhysicalModel(
    request: PhysicalModelValue,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  setPhysicalModel(
    request: PhysicalModelValue,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  setPhysicalModel(
    request: PhysicalModelValue,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  getPhysicalModel(
    request: PhysicalModelValue,
    callback: (error: ServiceError | null, response: PhysicalModelValue) => void,
  ): ClientUnaryCall;
  getPhysicalModel(
    request: PhysicalModelValue,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PhysicalModelValue) => void,
  ): ClientUnaryCall;
  getPhysicalModel(
    request: PhysicalModelValue,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PhysicalModelValue) => void,
  ): ClientUnaryCall;
  streamPhysicalModel(
    request: PhysicalModelValue,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<PhysicalModelValue>;
  streamPhysicalModel(
    request: PhysicalModelValue,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<PhysicalModelValue>;
  /**
   * Atomically set/get the current primary clipboard data.
   * Note that a call to setClipboard will result in an immediate
   * event for those who made a call to streamClipboard and are
   * on a different channel than the one used to set the clipboard.
   */
  setClipboard(request: ClipData, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  setClipboard(
    request: ClipData,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  setClipboard(
    request: ClipData,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  getClipboard(request: Empty, callback: (error: ServiceError | null, response: ClipData) => void): ClientUnaryCall;
  getClipboard(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ClipData) => void,
  ): ClientUnaryCall;
  getClipboard(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ClipData) => void,
  ): ClientUnaryCall;
  /**
   * Streams the current data on the clipboard. This will immediately produce
   * a result with the current state of the clipboard after which the stream
   * will block and wait until a new clip event is available from the guest.
   * Calling the setClipboard method above will not result in generating a
   * clip event. It is possible to lose clipboard events if the clipboard
   * updates very rapidly.
   */
  streamClipboard(request: Empty, options?: Partial<CallOptions>): ClientReadableStream<ClipData>;
  streamClipboard(request: Empty, metadata?: Metadata, options?: Partial<CallOptions>): ClientReadableStream<ClipData>;
  /** Set/get the battery to the given state. */
  setBattery(request: BatteryState, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  setBattery(
    request: BatteryState,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  setBattery(
    request: BatteryState,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  getBattery(request: Empty, callback: (error: ServiceError | null, response: BatteryState) => void): ClientUnaryCall;
  getBattery(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BatteryState) => void,
  ): ClientUnaryCall;
  getBattery(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BatteryState) => void,
  ): ClientUnaryCall;
  /**
   * Set the state of the gps.
   * Note: Setting the gps position will not be reflected in the user
   * interface. Keep in mind that android usually only samples the gps at 1
   * hz.
   */
  setGps(request: GpsState, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  setGps(
    request: GpsState,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  setGps(
    request: GpsState,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /**
   * Gets the latest gps state as delivered by the setGps call, or location ui
   * if active.
   *
   * Note: this is not necessarily the actual gps coordinate visible at the
   * time, due to gps sample frequency (usually 1hz).
   */
  getGps(request: Empty, callback: (error: ServiceError | null, response: GpsState) => void): ClientUnaryCall;
  getGps(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GpsState) => void,
  ): ClientUnaryCall;
  getGps(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GpsState) => void,
  ): ClientUnaryCall;
  /** Simulate a touch event on the finger print sensor. */
  sendFingerprint(
    request: Fingerprint,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  sendFingerprint(
    request: Fingerprint,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  sendFingerprint(
    request: Fingerprint,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /** Send a keyboard event. Translating the event. */
  sendKey(request: KeyboardEvent, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  sendKey(
    request: KeyboardEvent,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  sendKey(
    request: KeyboardEvent,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /**
   * Send touch/mouse events. Note that mouse events can be simulated
   * by touch events.
   */
  sendTouch(request: TouchEvent, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  sendTouch(
    request: TouchEvent,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  sendTouch(
    request: TouchEvent,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  sendMouse(request: MouseEvent, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  sendMouse(
    request: MouseEvent,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  sendMouse(
    request: MouseEvent,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  injectWheel(callback: (error: ServiceError | null, response: Empty) => void): ClientWritableStream<WheelEvent>;
  injectWheel(
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<WheelEvent>;
  injectWheel(
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<WheelEvent>;
  injectWheel(
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<WheelEvent>;
  /**
   * Stream a series of input events to the emulator, the events will
   * arrive in order.
   */
  streamInputEvent(callback: (error: ServiceError | null, response: Empty) => void): ClientWritableStream<InputEvent>;
  streamInputEvent(
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<InputEvent>;
  streamInputEvent(
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<InputEvent>;
  streamInputEvent(
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<InputEvent>;
  /** Make a phone call. */
  sendPhone(
    request: PhoneCall,
    callback: (error: ServiceError | null, response: PhoneResponse) => void,
  ): ClientUnaryCall;
  sendPhone(
    request: PhoneCall,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PhoneResponse) => void,
  ): ClientUnaryCall;
  sendPhone(
    request: PhoneCall,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PhoneResponse) => void,
  ): ClientUnaryCall;
  /** Sends an sms message to the emulator. */
  sendSms(
    request: SmsMessage,
    callback: (error: ServiceError | null, response: PhoneResponse) => void,
  ): ClientUnaryCall;
  sendSms(
    request: SmsMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PhoneResponse) => void,
  ): ClientUnaryCall;
  sendSms(
    request: SmsMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PhoneResponse) => void,
  ): ClientUnaryCall;
  /** Sends an sms message to the emulator. */
  setPhoneNumber(
    request: PhoneNumber,
    callback: (error: ServiceError | null, response: PhoneResponse) => void,
  ): ClientUnaryCall;
  setPhoneNumber(
    request: PhoneNumber,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PhoneResponse) => void,
  ): ClientUnaryCall;
  setPhoneNumber(
    request: PhoneNumber,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PhoneResponse) => void,
  ): ClientUnaryCall;
  /**
   * Retrieve the status of the emulator. This will contain general
   * hardware information, and whether the device has booted or not.
   */
  getStatus(request: Empty, callback: (error: ServiceError | null, response: EmulatorStatus) => void): ClientUnaryCall;
  getStatus(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EmulatorStatus) => void,
  ): ClientUnaryCall;
  getStatus(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EmulatorStatus) => void,
  ): ClientUnaryCall;
  /**
   * Gets an individual screenshot in the desired format.
   *
   * The image will be scaled to the desired ImageFormat, while maintaining
   * the aspect ratio. The returned image will never exceed resolution of the
   * device display. Not setting the width or height (i.e. they are 0) will
   * result in using the display width and height.
   *
   * The resulting image will be properly oriented and can be displayed
   * directly without post processing. For example, if the device has a
   * 1080x1920 screen and is in landscape mode and called with no width or
   * height parameter, it will return a 1920x1080 image.
   *
   * The dimensions of the returned image will never exceed the corresponding
   * display dimensions. For example, this method will return a 1920x1080
   * screenshot, if the display resolution is 1080x1920 and a screenshot of
   * 2048x2048 is requested when the device is in landscape mode.
   *
   * This method will return an empty image if the display is not visible.
   */
  getScreenshot(request: ImageFormat, callback: (error: ServiceError | null, response: Image) => void): ClientUnaryCall;
  getScreenshot(
    request: ImageFormat,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Image) => void,
  ): ClientUnaryCall;
  getScreenshot(
    request: ImageFormat,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Image) => void,
  ): ClientUnaryCall;
  /**
   * Streams a series of screenshots in the desired format.
   *
   * A new frame will be delivered whenever the device produces a new frame.
   * Beware that this can produce a significant amount of data and that
   * certain translations can be very costly. For example, streaming a series
   * of png images is very cpu intensive.
   *
   * Images are produced according to the getScreenshot API described above.
   *
   * If the display is inactive, or becomes inactive, an empty image will be
   * delivered. Images will be delived again if the display becomes active and
   * new frames are produced.
   */
  streamScreenshot(request: ImageFormat, options?: Partial<CallOptions>): ClientReadableStream<Image>;
  streamScreenshot(
    request: ImageFormat,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<Image>;
  /**
   * Streams a series of audio packets in the desired format.
   * A new frame will be delivered whenever the emulated device
   * produces a new audio frame. You can expect packets to be
   * delivered in intervals of 20-30ms.
   *
   * Be aware that this can block when the emulator does not
   * produce any audio whatsoever!
   */
  streamAudio(request: AudioFormat, options?: Partial<CallOptions>): ClientReadableStream<AudioPacket>;
  streamAudio(
    request: AudioFormat,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<AudioPacket>;
  /**
   * Injects a series of audio packets to the android microphone.
   * A new frame will be delivered whenever the emulated device
   * requests a new audio frame. Audio is usually delivered at a rate
   * that the emulator is requesting frames. Audio will be stored in a
   * temporary buffer that can hold 300ms of audio.
   *
   * Notes:
   *  - Only the first audio format packet that is delivered will be
   * honored. There is no need to send the audio format multiple times.
   *  - Real time audio currently immediately overrides the buffer. This
   * means you must provide a constant rate of audio packets. The real
   * time mode is experimental. Timestamps of audio packets might be
   * used in the future to improve synchronization.
   *
   * -  INVALID_ARGUMENT (code 3) The sampling rate was too high/low
   * -  INVALID_ARGUMENT (code 3) The audio packet was too large to handle.
   * -  FAILED_PRECONDITION (code 9) If there was a microphone registered
   * already.
   */
  injectAudio(callback: (error: ServiceError | null, response: Empty) => void): ClientWritableStream<AudioPacket>;
  injectAudio(
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<AudioPacket>;
  injectAudio(
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<AudioPacket>;
  injectAudio(
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<AudioPacket>;
  /**
   * Deprecated, please use the streamLogcat method instead.
   *
   * @deprecated
   */
  getLogcat(request: LogMessage, callback: (error: ServiceError | null, response: LogMessage) => void): ClientUnaryCall;
  getLogcat(
    request: LogMessage,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LogMessage) => void,
  ): ClientUnaryCall;
  getLogcat(
    request: LogMessage,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LogMessage) => void,
  ): ClientUnaryCall;
  /**
   * Streams the logcat output from the emulator.
   * Note that parsed logcat messages are only available after L (Api >23)
   */
  streamLogcat(request: LogMessage, options?: Partial<CallOptions>): ClientReadableStream<LogMessage>;
  streamLogcat(
    request: LogMessage,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<LogMessage>;
  /**
   * Transition the virtual machine to the desired state. Note that
   * some states are only observable. For example you cannot transition
   * to the error state.
   */
  setVmState(request: VmRunState, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  setVmState(
    request: VmRunState,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  setVmState(
    request: VmRunState,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /** Gets the state of the virtual machine. */
  getVmState(request: Empty, callback: (error: ServiceError | null, response: VmRunState) => void): ClientUnaryCall;
  getVmState(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VmRunState) => void,
  ): ClientUnaryCall;
  getVmState(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VmRunState) => void,
  ): ClientUnaryCall;
  /**
   * Atomically changes the current multi-display configuration.
   * After this call the given display configurations will be activated. You
   * can only update secondary displays. Displays with id 0 will be ignored.
   *
   * This call can result in the removal or addition of secondary displays,
   * the final display state can be observed by the returned configuration.
   *
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD does not support a
   * configurable
   *    secondary display.
   * -  INVALID_ARGUMENT (code 3) if:
   *     - The same display id is defined multiple times.
   *     - The display configurations are outside valid ranges.
   *       See DisplayConfiguration for details on valid ranges.
   * -  INTERNAL (code 13) if there was an internal emulator failure.
   */
  setDisplayConfigurations(
    request: DisplayConfigurations,
    callback: (error: ServiceError | null, response: DisplayConfigurations) => void,
  ): ClientUnaryCall;
  setDisplayConfigurations(
    request: DisplayConfigurations,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DisplayConfigurations) => void,
  ): ClientUnaryCall;
  setDisplayConfigurations(
    request: DisplayConfigurations,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DisplayConfigurations) => void,
  ): ClientUnaryCall;
  /**
   * Returns all currently valid logical displays.
   *
   * The gRPC error code FAILED_PRECONDITION (code 9) is returned if the AVD
   * does not support a configurable secondary display.
   */
  getDisplayConfigurations(
    request: Empty,
    callback: (error: ServiceError | null, response: DisplayConfigurations) => void,
  ): ClientUnaryCall;
  getDisplayConfigurations(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DisplayConfigurations) => void,
  ): ClientUnaryCall;
  getDisplayConfigurations(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DisplayConfigurations) => void,
  ): ClientUnaryCall;
  /**
   * Notifies client of the following changes:
   *
   * - Virtual scene camera status change.
   * - Display configuration changes from extended ui. This will only be fired
   *   if the user makes modifications the extended displays through the
   *   extended control tab.
   *
   * Note that this method will send the initial virtual scene state
   * immediately.
   */
  streamNotification(request: Empty, options?: Partial<CallOptions>): ClientReadableStream<Notification>;
  streamNotification(
    request: Empty,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<Notification>;
  /**
   * Rotation angles are relative to the camera's current orientation.
   * The coordinate system is right-handed and is defined as follows:
   *   x axis is pointing right
   *   y axis is pointing up
   *   z axis is pointing towards the viewer
   * The z component of rotation is not used when calling this method.
   */
  rotateVirtualSceneCamera(
    request: RotationRadian,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  rotateVirtualSceneCamera(
    request: RotationRadian,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  rotateVirtualSceneCamera(
    request: RotationRadian,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /**
   * Velocity is absolute and is measured in meters per second.
   * The coordinate system is right-handed and is defined as follows:
   *   x axis is pointing right
   *   y axis is pointing up
   *   z axis is pointing towards the viewer
   */
  setVirtualSceneCameraVelocity(
    request: Velocity,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  setVirtualSceneCameraVelocity(
    request: Velocity,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  setVirtualSceneCameraVelocity(
    request: Velocity,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /** Set foldable posture */
  setPosture(request: Posture, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  setPosture(
    request: Posture,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  setPosture(
    request: Posture,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /**
   * Get the backlight brightness.
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD does not support hw-control.
   */
  getBrightness(
    request: BrightnessValue,
    callback: (error: ServiceError | null, response: BrightnessValue) => void,
  ): ClientUnaryCall;
  getBrightness(
    request: BrightnessValue,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BrightnessValue) => void,
  ): ClientUnaryCall;
  getBrightness(
    request: BrightnessValue,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BrightnessValue) => void,
  ): ClientUnaryCall;
  /**
   * Set the backlight brightness.
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD does not support hw-control.
   * -  INVALID_ARGUMENT (code 3) The brightness exceeds the valid range.
   */
  setBrightness(
    request: BrightnessValue,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  setBrightness(
    request: BrightnessValue,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  setBrightness(
    request: BrightnessValue,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /**
   * Returns the current mode of the primary display of a resizable AVD.
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD is not resizable.
   */
  getDisplayMode(
    request: Empty,
    callback: (error: ServiceError | null, response: DisplayMode) => void,
  ): ClientUnaryCall;
  getDisplayMode(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DisplayMode) => void,
  ): ClientUnaryCall;
  getDisplayMode(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DisplayMode) => void,
  ): ClientUnaryCall;
  /**
   * Sets the size of the primary display of a resizable AVD. Fails if the AVD
   * is not resizable. The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD is not resizable.
   */
  setDisplayMode(
    request: DisplayMode,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  setDisplayMode(
    request: DisplayMode,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  setDisplayMode(
    request: DisplayMode,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const EmulatorControllerClient = makeGenericClientConstructor(
  EmulatorControllerService,
  "android.emulation.control.EmulatorController",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): EmulatorControllerClient;
  service: typeof EmulatorControllerService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
